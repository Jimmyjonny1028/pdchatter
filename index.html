<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Toolkit</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/+esm"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .chat-bubble {
            max-width: 90%;
            word-wrap: break-word;
            white-space: pre-wrap;
            margin-bottom: 0.5rem;
        }

        .user-bubble {
            background-color: #3b82f6;
            color: white;
            border-radius: 1rem 1rem 0.25rem 1rem;
        }

        .ai-bubble {
            background-color: #4b5563;
            color: #e5e7eb;
            border-radius: 1rem 1rem 1rem 0.25rem;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .modal-content {
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.75rem;
            width: 90%;
            max-width: 400px;
            color: #d1d5db;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .modal-content input {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }

        .modal-content label {
            color: #9ca3af;
            margin-bottom: 0.25rem;
            display: block;
        }

        .thoughts-bubble {
            background-color: #1f2937;
            color: #cbd5e1;
            display: inline-flex;
            align-items: center;
            padding: 0.6rem 1rem;
            border-radius: 1rem 1rem 1rem 0.25rem;
            align-self: flex-start;
            margin-right: auto;
            margin: 0.5rem 0;
            border-left: 3px solid #6366f1;
        }

        .thoughts-bubble details summary {
            list-style: none;
            padding: 0.25rem 0;
            cursor: pointer;
            outline: none;
            color: #a5b4fc;
            font-weight: 500;
        }

        .thoughts-bubble details[open] summary {
            border-bottom: 1px solid #374151;
            margin-bottom: 0.75rem;
            padding-bottom: 0.25rem;
        }

        .thoughts-content pre {
            background-color: #111827;
            padding: 0.75rem;
            border-radius: 0.375rem;
            white-space: pre-wrap;
            overflow-x: auto;
            font-size: 0.85em;
        }

        .speed-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            opacity: 0.9;
            font-weight: 600;
            white-space: nowrap;
        }

        .speed-button:hover {
            opacity: 1;
            background-color: #6366f1;
        }

        .speed-button.fast-active {
            background-color: #f59e0b;
            opacity: 1;
        }

        .code-block-container {
            position: relative;
            background-color: #111827;
            border-radius: 0.5rem;
            margin: 1rem 0;
            padding: 0;
            overflow: hidden;
            border: 1px solid #374151;
        }

        .code-block-container .language-tag {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #374151;
            color: #9ca3af;
            padding: 0.1rem 0.5rem;
            font-size: 0.7rem;
            border-top-left-radius: 0.5rem;
            z-index: 10;
        }

        .code-block-container ol {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            font-size: 0.875rem;
        }

        .line-numbers {
            background-color: #1f2937;
            color: #6b7280;
            text-align: right;
            padding: 0.75rem 0.5rem;
            user-select: none;
            line-height: 1.6;
            border-right: 1px solid #374151;
        }

        .code-content {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            overflow-x: auto;
        }

        .code-content code {
            display: block;
            white-space: pre;
            color: #d1d5db;
            line-height: 1.6;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
        }

        .retry-button {
            background-color: #ef4444;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 600;
            margin-top: 0.5rem;
            transition: background-color 0.2s;
        }

        .retry-button:hover {
            background-color: #dc2626;
        }

        .error-retry-container-pdf,
        .error-retry-container-ai {
            display: none;
            justify-content: center;
            padding: 0 1rem 0.5rem 1rem;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
            border: 2px solid #1f2937;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        .ai-bubble pre {
            background-color: #111827;
            border: 1px solid #374151;
            color: #d1d5db;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            position: relative;
            font-size: 0.875rem;
        }

        .ai-bubble code {
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
        }

        .user-bubble img {
            max-width: 150px;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #374151;
            color: #9ca3af;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 10;
        }

        pre:hover .copy-button,
        .code-block-container:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background-color: #4b5563;
            color: #e5e7eb;
        }

        .ai-bubble table {
            width: 100%;
            margin: 1em 0;
            border-collapse: collapse;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .ai-bubble th,
        .ai-bubble td {
            border: 1px solid #4b5563;
            padding: 0.6rem 0.8rem;
            text-align: left;
        }

        .ai-bubble th {
            background-color: #1f2937;
            font-weight: 600;
        }

        .ai-bubble tr:nth-child(even) {
            background-color: rgba(55, 65, 81, 0.5);
        }

        .thinking-bubble {
            background-color: #4b5563;
            color: #cbd5e1;
            display: inline-flex;
            align-items: center;
            padding: 0.6rem 1rem;
            border-radius: 1rem 1rem 1rem 0.25rem;
            align-self: flex-start;
            margin: 0.5rem 0;
        }

        .thinking-bubble span {
            margin-right: 0.5rem;
        }

        .dot-flashing {
            position: relative;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #9ca3af;
            color: #9ca3af;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: 0.5s;
            margin: 0 3px;
        }

        .dot-flashing::before,
        .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #9ca3af;
            color: #9ca3af;
        }

        .dot-flashing::before {
            left: -12px;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }

        .dot-flashing::after {
            left: 12px;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }

        @keyframes dotFlashing {
            0% {
                background-color: #9ca3af;
            }
            50%,
            100% {
                background-color: rgba(156, 163, 175, 0.3);
            }
        }

        .delete-chat-btn {
            margin-left: auto;
            padding: 0 0.5rem;
            color: #f87171;
            background: none;
            border: none;
            font-size: 1.25rem;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, color 0.2s;
        }

        .delete-chat-btn:hover {
            color: #ef4444;
            opacity: 1;
        }

        .sidebar-chat-item {
            transition: background-color 0.2s;
        }

        .web-search-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background-color: #1f2937;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .web-search-toggle input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            cursor: pointer;
        }

        .web-search-toggle label {
            font-size: 0.875rem;
            color: #d1d5db;
            cursor: pointer;
            margin: 0;
        }
    </style>
</head>
<body class="bg-slate-900 h-screen overflow-hidden text-slate-200">
    <div id="auth-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="auth-title" class="text-2xl font-bold mb-4 text-white">Login</h2>
            <div id="auth-error" class="text-red-400 mb-2" style="display: none;"></div>
            <form id="auth-form">
                <div class="mb-4">
                    <label for="username" class="block mb-1 text-slate-300">Username</label>
                    <input
                        type="text"
                        id="username"
                        class="w-full bg-slate-700 border border-slate-600 rounded p-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                        required
                    >
                </div>
                <div class="mb-6">
                    <label for="password" class="block mb-1 text-slate-300">Password</label>
                    <input
                        type="password"
                        id="password"
                        class="w-full bg-slate-700 border border-slate-600 rounded p-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                        required
                    >
                </div>
                <div class="flex justify-between items-center">
                    <div>
                        <button
                            type="submit"
                            id="auth-submit-button"
                            class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded text-white font-semibold transition duration-200 disabled:opacity-50"
                            disabled
                        >
                            Login
                        </button>
                        <button
                            type="button"
                            id="auth-close-button"
                            class="text-slate-400 hover:text-white ml-2"
                        >
                            Cancel
                        </button>
                    </div>
                    <button
                        type="button"
                        id="auth-switch-button"
                        class="text-sm text-indigo-400 hover:underline"
                    >
                        Need an account? Sign up
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div class="flex h-full">
        <aside id="chat-sidebar" class="w-64 bg-slate-800 text-slate-100 flex flex-col p-4 transform -translate-x-full fixed h-full z-20 shadow-lg border-r border-slate-700">
            <div class="flex justify-between items-center mb-4 border-b border-slate-600 pb-2">
                <h2 id="sidebar-title" class="text-xl font-semibold">Saved Chats</h2>
                <button id="close-sidebar-button" class="text-slate-400 hover:text-white text-2xl leading-none p-1 rounded hover:bg-slate-700">√ó</button>
            </div>
            <div id="user-status" class="text-center text-sm text-slate-400 mb-2">Guest Mode</div>
            <button id="new-chat-button" class="w-full text-left p-2 mb-2 bg-indigo-600 rounded hover:bg-indigo-700 text-white font-semibold transition duration-200">
                New Chat
            </button>
            <div id="saved-chats-list" class="flex-1 overflow-y-auto space-y-1 pr-1"></div>
        </aside>

        <div class="flex-1 flex flex-col h-full bg-slate-900">
            <header class="bg-slate-800 shadow-md p-4 flex items-center justify-between z-10 border-b border-slate-700">
                <div class="flex items-center space-x-4">
                    <button id="open-sidebar-button" class="p-2 rounded-md text-slate-300 hover:bg-slate-700 hover:text-white transition duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                    </button>
                    <h1 class="text-2xl font-bold text-slate-100">AI Toolkit</h1>
                </div>
                <p id="status" class="text-sm text-slate-400">Status: Connecting to server...</p>
                <div class="flex items-center space-x-2">
                    <button id="tab-chatpdf" class="tab-button py-2 px-3 text-slate-400 font-semibold border-b-2 hover:text-indigo-400 transition duration-200">ChatPDF</button>
                    <button id="tab-ai-chat" class="tab-button py-2 px-3 text-slate-400 font-semibold border-b-2 hover:text-indigo-400 transition duration-200">AI Chat</button>
                    <button id="login-button" class="bg-indigo-600 text-white px-4 py-1.5 rounded-md hover:bg-indigo-700 font-semibold transition duration-200">Login / Sign Up</button>
                    <button id="logout-button" class="bg-red-600 text-white px-4 py-1.5 rounded-md hover:bg-red-700 font-semibold transition duration-200" style="display: none;">Logout</button>
                </div>
            </header>

            <div id="view-chatpdf" class="flex-1 grid md:grid-cols-2 gap-4 p-4 overflow-hidden">
                <section class="bg-slate-700 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-600">
                    <div class="p-2 border-b border-slate-600 bg-slate-800">
                        <h2 id="pdf-title" class="text-lg font-semibold text-slate-200 truncate">PDF Preview</h2>
                    </div>
                    <div class="flex-1 p-2 bg-slate-600">
                        <embed id="pdf-viewer" src="" type="application/pdf" width="100%" height="100%">
                    </div>
                </section>

                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-700">
                    <main id="chat-container" class="flex-1 p-4 space-y-2 overflow-y-auto"></main>
                    <div id="error-retry-container-pdf" class="bg-slate-800 px-4 pb-2"></div>
                    <footer class="bg-slate-900 p-3 border-t border-slate-700">
                        <div class="flex items-center space-x-2">
                            <label for="pdf-upload" id="upload-label" class="cursor-not-allowed bg-slate-500 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-200 opacity-50">
                                Upload
                            </label>
                            <input id="pdf-upload" type="file" class="hidden" accept=".pdf" disabled>
                            <button id="fast-mode-button-pdf" class="speed-button text-sm px-3 py-2">Fast Paste</button>
                            <input
                                type="text"
                                id="message-input"
                                class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-transparent"
                                placeholder="Connecting..."
                                disabled
                            >
                            <button id="send-button" class="bg-slate-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>

            <div id="view-ai-chat" style="display: none;" class="flex-1 flex flex-col p-4 overflow-hidden">
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-700">
                    <main id="chat-container-ai" class="flex-1 p-4 space-y-2 overflow-y-auto"></main>

                    <div id="image-preview-container-ai" class="p-3 border-t border-slate-700 bg-slate-900" style="display: none;">
                        <div class="relative w-20 h-20">
                            <img id="image-preview-ai" class="w-full h-full object-cover rounded-md border border-slate-600">
                            <button id="remove-image-button-ai" class="absolute top-0 right-0 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs -mt-2 -mr-2 leading-none hover:bg-red-700">√ó</button>
                        </div>
                    </div>

                    <div id="error-retry-container-ai" class="bg-slate-800 px-4 pb-2"></div>

                    <footer class="bg-slate-900 p-3 border-t border-slate-700">
                        <!-- Web Search Toggle - FIXED -->
                        <div class="web-search-toggle">
                            <input type="checkbox" id="webSearchToggle" class="w-5 h-5 cursor-pointer">
                            <label for="webSearchToggle" class="cursor-pointer">
                                üîç Enable Live Web Search
                            </label>
                        </div>

                        <div class="flex items-center space-x-2">
                            <label for="image-upload-ai" class="cursor-pointer text-slate-400 hover:text-indigo-400 p-2 rounded hover:bg-slate-700 transition duration-200">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                                </svg>
                            </label>
                            <input id="image-upload-ai" type="file" class="hidden" accept="image/jpeg,image/png">
                            <button id="fast-mode-button-ai" class="speed-button text-sm px-3 py-2">Fast Paste</button>
                            <input
                                type="text"
                                id="message-input-ai"
                                class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-transparent"
                                placeholder="Connecting..."
                                disabled
                            >
                            <button id="send-button-ai" class="bg-slate-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.umd.js"></script>

    <script>


        const ui = {
            status: document.getElementById('status'),
            sidebar: document.getElementById('chat-sidebar'),
            sidebarTitle: document.getElementById('sidebar-title'),
            openSidebarButton: document.getElementById('open-sidebar-button'),
            closeSidebarButton: document.getElementById('close-sidebar-button'),
            newChatButton: document.getElementById('new-chat-button'),
            savedChatsList: document.getElementById('saved-chats-list'),
            userStatus: document.getElementById('user-status'),
            tabChatPDF: document.getElementById('tab-chatpdf'),
            tabAIChat: document.getElementById('tab-ai-chat'),
            viewChatPDF: document.getElementById('view-chatpdf'),
            viewAIChat: document.getElementById('view-ai-chat'),
            chatContainer: document.getElementById('chat-container'),
            messageInput: document.getElementById('message-input'),
            sendButton: document.getElementById('send-button'),
            pdfUploadInput: document.getElementById('pdf-upload'),
            uploadLabel: document.getElementById('upload-label'),
            pdfViewer: document.getElementById('pdf-viewer'),
            pdfTitle: document.getElementById('pdf-title'),
            fastModeButtonPdf: document.getElementById('fast-mode-button-pdf'),
            errorRetryContainerPdf: document.getElementById('error-retry-container-pdf'),
            chatContainerAI: document.getElementById('chat-container-ai'),
            messageInputAI: document.getElementById('message-input-ai'),
            sendButtonAI: document.getElementById('send-button-ai'),
            imageUploadAI: document.getElementById('image-upload-ai'),
            imagePreviewContainerAI: document.getElementById('image-preview-container-ai'),
            imagePreviewAI: document.getElementById('image-preview-ai'),
            removeImageButtonAI: document.getElementById('remove-image-button-ai'),
            fastModeButtonAi: document.getElementById('fast-mode-button-ai'),
            errorRetryContainerAi: document.getElementById('error-retry-container-ai'),
            authModal: document.getElementById('auth-modal'),
            authTitle: document.getElementById('auth-title'),
            authError: document.getElementById('auth-error'),
            authForm: document.getElementById('auth-form'),
            authSubmitButton: document.getElementById('auth-submit-button'),
            authCloseButton: document.getElementById('auth-close-button'),
            authSwitchButton: document.getElementById('auth-switch-button'),
            loginButton: document.getElementById('login-button'),
            logoutButton: document.getElementById('logout-button'),
            usernameInput: document.getElementById('username'),
            passwordInput: document.getElementById('password'),
            webSearchToggle: document.getElementById('webSearchToggle'),
        };

        let pdfChatHistory = [];
        let aiChatHistory = [];
        let currentPDFName = null;
        let activeTab = 'pdfchat';
        let uploadedImageB64 = null;
        let fastMode = false;
        let lastUserMessageText = null;
        let lastUserMessageImageB64 = null;
        let isLoginMode = true;
        let socket, statusInterval, pingInterval;
        let thinkingBubbleElement = null;
        let guestId;

        const RENDERAPIBASEURL = 'https://chatpdf-server-shtq.onrender.com';

        try {
            guestId = localStorage.getItem('aitoolkit:userid');
            if (!guestId) {
                guestId = 'guest' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('aitoolkit:userid', guestId);
            }
        } catch (e) {
            console.warn('localStorage is not available. Using temporary guest ID.', e.message);
            guestId = 'guest' + Math.random().toString(36).substr(2, 9);
        }

        let streamingState = {
            pdfchat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
            aichat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
            pdfthoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' },
            aithoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' }
        };

        let renderInterval = null;
        const RENDERSPEED = 10;
        const CHARSPERTICK = 3;

        function addMessage(text, sender, target, imageB64 = null) {
            const history = target.startsWith('ai') ? aiChatHistory : pdfChatHistory;
            const container = target.startsWith('ai') ? ui.chatContainerAI : ui.chatContainer;

            if (target.endsWith('thoughts')) {
                const bubble = document.createElement('div');
                bubble.classList.add('thoughts-bubble', 'w-full', 'self-start', 'mr-auto');
                const details = document.createElement('details');
                details.classList.add('w-full');
                const summary = document.createElement('summary');
                summary.textContent = '...AI is thinking... Click to view';
                const contentDiv = document.createElement('div');
                contentDiv.classList.add('thoughts-content', 'pt-2', 'pb-1');
                details.appendChild(summary);
                details.appendChild(contentDiv);
                bubble.appendChild(details);
                container.appendChild(bubble);
                container.scrollTop = container.scrollHeight;
                return { bubble, contentDiv, summary };
            }

            if (sender === 'system') {
                const bubble = document.createElement('div');
                bubble.classList.add('text-center', 'text-xs', 'text-slate-400', 'my-2', 'px-4');
                bubble.textContent = text;
                container.appendChild(bubble);
                container.scrollTop = container.scrollHeight;
                return { bubble, contentDiv: bubble, summary: null };
            }

            const bubble = document.createElement('div');
            bubble.classList.add('chat-bubble', 'p-3', 'w-fit', 'my-1');

            if (sender === 'user') {
                bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
            } else {
                bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
            }

            const textNode = document.createElement('div');
            textNode.textContent = text;
            bubble.appendChild(textNode);

            if (sender === 'user' && imageB64) {
                const img = document.createElement('img');
                img.src = 'data:image/jpeg;base64,' + imageB64;
                img.className = 'mt-2 rounded max-w-xs';
                bubble.appendChild(img);
            }

            container.appendChild(bubble);
            requestAnimationFrame(() => {
                if (container) container.scrollTop = container.scrollHeight;
            });

            if (sender === 'user') {
                history.push({ sender, text, imageB64 });
            }

            return { bubble, contentDiv: textNode, summary: null };
        }

        async function fetchWithAuth(url, options = {}) {
            const token = localStorage.getItem('aitoolkit:token');
            const headers = {
                ...options.headers,
                'Content-Type': 'application/json',
            };

            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            try {
                const response = await fetch(url, { ...options, headers });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                    console.error('API Error', response.status, errorData);
                    addMessage(`API Error: ${errorData.detail || response.statusText}`, 'system', activeTab);
                    throw new Error(errorData.detail || `HTTP error! status ${response.status}`);
                }

                if (response.status === 204) return null;

                const contentType = response.headers.get('content-type');
                if (contentType && contentType.indexOf('application/json') !== -1) {
                    return await response.json();
                } else {
                    console.warn('Received non-JSON response from API');
                    return await response.text();
                }
            } catch (error) {
                console.error('Fetch error', error);
                addMessage(`Network or Server Error: ${error.message}`, 'system', activeTab);
                throw error;
            }
        }

        function showAuthModal(show) {
            ui.authModal.style.display = show ? 'flex' : 'none';
            if (!show) {
                ui.authError.style.display = 'none';
                ui.authForm.reset();
                ui.authSubmitButton.disabled = true;
            } else {
                ui.authSubmitButton.disabled = !ui.usernameInput.value.trim() || !ui.passwordInput.value.trim();
            }
        }

        function updateAuthUI() {
            const token = localStorage.getItem('aitoolkit:token');
            if (token) {
                try {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    ui.userStatus.textContent = `Logged in: ${payload.sub}`;
                    ui.loginButton.style.display = 'none';
                    ui.logoutButton.style.display = 'block';
                } catch (e) {
                    handleLogout();
                }
            } else {
                ui.userStatus.textContent = 'Guest Mode';
                ui.loginButton.style.display = 'block';
                ui.logoutButton.style.display = 'none';
            }
        }

        async function handleAuthSubmit(event) {
            event.preventDefault();
            const username = ui.usernameInput.value.trim();
            const password = ui.passwordInput.value.trim();

            if (!username || !password) return;

            const endpoint = isLoginMode ? `${RENDERAPIBASEURL}/login` : `${RENDERAPIBASEURL}/signup`;
            ui.authSubmitButton.disabled = true;
            ui.authSubmitButton.textContent = isLoginMode ? 'Logging in...' : 'Signing up...';
            ui.authError.textContent = '';
            ui.authError.style.display = 'none';

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password }),
                });

                const contentType = response.headers.get('content-type');
                let data;
                if (contentType && contentType.indexOf('application/json') !== -1) {
                    data = await response.json();
                } else {
                    const textResponse = await response.text();
                    console.error('Non-JSON Auth Response', textResponse);
                    throw new Error(`Server returned status ${response.status}. Check server logs.`);
                }

                if (!response.ok) {
                    throw new Error(data.detail || 'An error occurred.');
                }

                if (isLoginMode) {
                    localStorage.setItem('aitoolkit:token', data.access_token);
                    showAuthModal(false);
                    updateAuthUI();
                    startNewChat();
                } else {
                    isLoginMode = true;
                    ui.authTitle.textContent = 'Login';
                    ui.authSubmitButton.textContent = 'Login';
                    ui.authSwitchButton.textContent = 'Need an account? Sign up';
                    ui.authError.style.display = 'block';
                    ui.authError.textContent = 'Signup successful! Please log in.';
                    ui.authForm.reset();
                }
            } catch (error) {
                ui.authError.style.display = 'block';
                ui.authError.textContent = error.message;
            } finally {
                ui.authSubmitButton.textContent = isLoginMode ? 'Login' : 'Sign Up';
                ui.authSubmitButton.disabled = !username.trim() || !password.trim();
            }
        }

        function handleLogout() {
            localStorage.removeItem('aitoolkit:token');
            sessionStorage.removeItem('currentAIChatId');
            sessionStorage.removeItem('currentPdfChatId');
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.close(1000, 'User logged out');
            }
            updateAuthUI();
            startNewChat();
        }

        async function checkWorkerStatus() {
            try {
                const response = await fetch(`${RENDERAPIBASEURL}/status`);
                if (!response.ok) throw new Error('Server not reachable');

                const data = await response.json();
                if (data.worker_connected) {
                    if (!socket || socket.readyState === WebSocket.CLOSED) {
                        setUIState('workerready', 'AI worker connected. Authenticating...');
                        if (statusInterval) {
                            clearInterval(statusInterval);
                            statusInterval = null;
                        }
                        connectWebSocket();
                    }
                } else {
                    setUIState('waitingforworker', 'Waiting for local AI worker...');
                    if (!statusInterval && !socket) {
                        statusInterval = setInterval(checkWorkerStatus, 5000);
                    }
                }
            } catch (error) {
                console.error('Status check error', error);
                setUIState('error', 'Could not connect to server.');
                if (!statusInterval && !socket) {
                    statusInterval = setInterval(checkWorkerStatus, 5000);
                }
            }
        }

        function connectWebSocket() {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }

            const wsUrl = RENDERAPIBASEURL.replace('http', 'ws').replace('https', 'wss') + '/ws/web';
            console.log('Attempting WebSocket connection to', wsUrl);
            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                console.log('WebSocket connected. Sending auth...');
                const token = localStorage.getItem('aitoolkit:token');
                socket.send(JSON.stringify(
                    token
                        ? { type: 'auth', token: token }
                        : { type: 'auth', userid: guestId }
                ));

                if (pingInterval) clearInterval(pingInterval);
                pingInterval = setInterval(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'ping' }));
                    } else {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }
                }, 20000);
            };

            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('WS Message Received', message);

                    if (message.type === 'auth_success' || message.type === 'authsuccess') {
                        console.log('Authentication successful!');
                        setUIState('workerready', 'AI worker connected.');
                        if (currentPDFName && activeTab === 'pdfchat') {
                            setUIState('readytochat', `Ready: ${currentPDFName}`);
                        }
                        if (localStorage.getItem('aitoolkit:token')) {
                            setTimeout(() => loadSavedChats(), 100);
                        }
                        return;
                    }

                    handleServerMessage(message);
                } catch (error) {
                    console.error('Failed to handle message', error, event.data);
                }
            };

            socket.onclose = (event) => {
                console.log('WebSocket closed', event.code, event.reason);
                clearInterval(pingInterval);
                pingInterval = null;

                const wasConnected = ui.status.textContent.includes('connected') || ui.status.textContent.includes('Ready');
                const wasStreaming = Object.values(streamingState).some(ss => ss?.active);
                const targetTab = activeTab;
                const intentionalClose = event.code === 1000;

                cleanupStreaming();
                socket = null;

                if (!intentionalClose && wasConnected) {
                    setUIState('disconnected', 'Disconnected. Trying to reconnect...');
                    if (!statusInterval) {
                        statusInterval = setInterval(checkWorkerStatus, 3000);
                    }
                } else if (!intentionalClose) {
                    setUIState('error', 'Connection failed. Retrying...');
                    if (!statusInterval) {
                        statusInterval = setInterval(checkWorkerStatus, 3000);
                    }
                } else {
                    setUIState('disconnected', 'Disconnected.');
                }

                if (wasStreaming && !intentionalClose) {
                    lastUserMessageText && showRetryButton(targetTab, `Connection lost (Code ${event.code}). Please retry.`);
                }
            };

            socket.onerror = (error) => {
                console.error('WebSocket Error', error);
            };
        }

        function setUIState(state, message) {
            ui.status.textContent = `Status: ${message}`;

            const isChatReady = state === 'readytochat';
            const isWorkerReady = state === 'workerready' || state === 'readytochat' || state === 'aithinking';
            const isConnected = state === 'workerready' || state === 'readytochat' || state === 'aithinking';

            ui.pdfUploadInput.disabled = !isWorkerReady;
            ui.uploadLabel.classList.toggle('cursor-not-allowed', !isWorkerReady);
            ui.uploadLabel.classList.toggle('cursor-pointer', isWorkerReady);
            ui.uploadLabel.classList.toggle('bg-slate-500', !isWorkerReady);
            ui.uploadLabel.classList.toggle('opacity-50', !isWorkerReady);
            ui.uploadLabel.classList.toggle('bg-blue-600', isWorkerReady);
            ui.uploadLabel.classList.toggle('hover:bg-blue-700', isWorkerReady);

            const isPdfStreaming = (streamingState.pdfchat.active || streamingState.pdfthoughts.active) && thinkingBubbleElement && activeTab === 'pdfchat';
            const isAiStreaming = (streamingState.aichat.active || streamingState.aithoughts.active) && thinkingBubbleElement && activeTab === 'aichat';

            const canUsePdfChat = isChatReady && !isPdfStreaming;
            ui.messageInput.disabled = !canUsePdfChat;
            ui.sendButton.disabled = !canUsePdfChat;
            ui.sendButton.classList.toggle('bg-slate-500', !canUsePdfChat);
            ui.sendButton.classList.toggle('opacity-50', !canUsePdfChat);
            ui.sendButton.classList.toggle('bg-indigo-600', canUsePdfChat);
            ui.sendButton.classList.toggle('hover:bg-indigo-700', canUsePdfChat);
            ui.messageInput.placeholder = canUsePdfChat
                ? 'Ask a question about the PDF...'
                : isPdfStreaming
                ? 'AI is processing...'
                : !isConnected
                ? 'Connecting...'
                : 'Upload a PDF to begin...';

            const canUseAiChat = isWorkerReady && !isAiStreaming && state !== 'processing';
            ui.messageInputAI.disabled = !canUseAiChat;
            ui.sendButtonAI.disabled = !canUseAiChat;
            ui.sendButtonAI.classList.toggle('bg-slate-500', !canUseAiChat);
            ui.sendButtonAI.classList.toggle('opacity-50', !canUseAiChat);
            ui.sendButtonAI.classList.toggle('bg-indigo-600', canUseAiChat);
            ui.sendButtonAI.classList.toggle('hover:bg-indigo-700', canUseAiChat);
            ui.messageInputAI.placeholder = canUseAiChat
                ? 'Send a message, or paste an image...'
                : isAiStreaming
                ? 'AI is processing...'
                : state === 'processing'
                ? 'Processing PDF...'
                : 'Connecting...';
        }

        function showThinkingBubble(tab) {
            removeThinkingBubble();
            const container = tab === 'aichat' ? ui.chatContainerAI : ui.chatContainer;
            thinkingBubbleElement = document.createElement('div');
            thinkingBubbleElement.classList.add('thinking-bubble');
            thinkingBubbleElement.innerHTML = '<span>AI is thinking</span><div class="dot-flashing"></div>';
            container.appendChild(thinkingBubbleElement);
            container.scrollTop = container.scrollHeight;
            setUIState('aithinking', 'AI is processing...');
        }

        function removeThinkingBubble() {
            if (thinkingBubbleElement) {
                thinkingBubbleElement.remove();
                thinkingBubbleElement = null;
            }
        }

        function sendMessage(question, tab, imageB64 = null, isRetry = false) {
            const trimmedQuestion = question.trim();

            if (!trimmedQuestion && !imageB64) return;

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                addMessage('Error: Not connected.', 'system', tab);
                return;
            }

            if (Object.values(streamingState).some(ss => ss?.active) && thinkingBubbleElement) {
                console.warn('Processing... Please wait.');
                return;
            }

            lastUserMessageText = trimmedQuestion;
            lastUserMessageImageB64 = imageB64;

            const history = tab === 'aichat' ? aiChatHistory : pdfChatHistory;

            if (!isRetry) {
                addMessage(trimmedQuestion, 'user', tab, imageB64);
                showThinkingBubble(tab);
            }

            const historyForWorker = history.map(msg => ({
                sender: msg.sender,
                text: msg.text,
            })).slice(0, isRetry ? undefined : -1);

            let payloadData = {
                question: trimmedQuestion,
                history: historyForWorker,
            };

            let taskType = tab === 'pdfchat' ? 'ask' : imageB64 ? 'general_chat_with_image' : 'general_chat';

            if (imageB64 && tab === 'aichat') {
                payloadData.image_b64 = imageB64;
            }

            // FIXED: Add web search toggle
            const enableWebSearch = ui.webSearchToggle.checked;
            payloadData.enable_web_search = enableWebSearch;

            socket.send(JSON.stringify({
                type: taskType,
                target: tab,
                data: payloadData,
            }));

            ui.messageInput.value = '';
            ui.messageInputAI.value = '';
            ui.imagePreviewContainerAI.style.display = 'none';
            ui.imageUploadAI.value = '';
            uploadedImageB64 = null;
        }

        function handleServerMessage(message) {
            const targetKey = message.target || activeTab;
            const isThought = targetKey.endsWith('thoughts');
            const mainTarget = isThought ? targetKey.replace('thoughts', 'chat') : targetKey;

            switch (message.type) {
                case 'status':
                    console.log('Received Status', message.data);
                    removeThinkingBubble();
                    addMessage(message.data, 'system', mainTarget);

                    if (message.data.includes('Ready for questions') && activeTab === 'pdfchat') {
                        console.log('Setting UI state to readytochat based on status message');
                        setUIState('readytochat', `Ready: ${currentPDFName}`);
                    } else if (!message.data.includes('Processing') && !message.data.includes('Ready for questions') && activeTab === 'pdfchat') {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            const currentState = ui.status.textContent;
                            if (!currentState.includes('Ready') && !currentState.includes('worker connected')) {
                                console.log('Setting UI state to workerready for general status');
                                setUIState('workerready', 'AI worker connected.');
                            }
                        }
                    }
                    break;

                case 'answer_chunk':
                    if (!isThought && !streamingState[targetKey]?.active) {
                        removeThinkingBubble();
                    }

                    if (!streamingState[targetKey]?.active) {
                        streamingState[targetKey] = {
                            active: true,
                            bubble: null,
                            contentDiv: null,
                            summary: null,
                            ended: false,
                            textBuffer: '',
                            currentText: '',
                            isCode: false,
                        };

                        if (isThought) {
                            const thoughtElements = addMessage('', 'ai', targetKey);
                            Object.assign(streamingState[targetKey], thoughtElements);
                        }

                        if (!renderInterval) {
                            renderInterval = setInterval(renderCharacters, RENDERSPEED);
                        }
                    }

                    if (streamingState[targetKey]) {
                        streamingState[targetKey].textBuffer += message.data;
                    }
                    break;

                case 'answer_end':
                    if (streamingState[targetKey]) {
                        streamingState[targetKey].ended = true;
                        if (isThought && streamingState[targetKey].summary) {
                            streamingState[targetKey].summary.textContent = 'View Thinking Process (Finished)';
                        }
                    }
                    
                    // FIXED: Clear thinking bubble when main chat stream ends
                    if (!isThought && !targetKey.endsWith('thoughts')) {
                        console.log('[ANSWER_END] Clearing thinking bubble for', targetKey);
                        removeThinkingBubble();
                    }
                    break;

                case 'error':
                    console.error('Received error message', message.data);
                    finalizeStream(mainTarget, true);
                    showRetryButton(mainTarget, message.data || 'An unknown error occurred.');
                    cleanupStreaming();

                    if (socket && socket.readyState === WebSocket.OPEN) {
                        if (currentPDFName && activeTab === 'pdfchat') {
                            setUIState('readytochat', `Ready: ${currentPDFName}`);
                        } else {
                            setUIState('workerready', 'AI worker connected.');
                        }
                    } else {
                        setUIState('error', 'Connection error occurred.');
                    }
                    break;

                case 'pong':
                    break;

                default:
                    console.warn('Unknown message type', message.type, message);
                    removeThinkingBubble();
            }
        }

        function renderCharacters() {
            const renderSpeed = fastMode ? 999999 : CHARSPERTICK;
            let anyActiveStreams = false;

            for (let key in streamingState) {
                const state = streamingState[key];
                if (!key || !state || !state.active) continue;

                anyActiveStreams = true;
                const isThought = key.endsWith('thoughts');
                const mainChatKey = isThought ? key.replace('thoughts', 'chat') : key;

                if (!isThought && !state.bubble) {
                    const answerElements = addMessage('', 'ai', mainChatKey);
                    if (answerElements) Object.assign(state, answerElements);
                }

                if (state.textBuffer.length > 0 && !state.ended) {
                    const charsToRender = Math.min(state.textBuffer.length, renderSpeed);
                    const chunk = state.textBuffer.substring(0, charsToRender);
                    state.currentText += chunk;
                    state.textBuffer = state.textBuffer.substring(charsToRender);

                    if (state.contentDiv) {
                        try {
                            state.contentDiv.innerHTML = marked.parse(state.currentText);
                        } catch (e) {
                            console.error('Markdown parsing error', e, state.currentText);
                            state.contentDiv.textContent = state.currentText;
                        }

                        if (!isThought) {
                            state.contentDiv.querySelectorAll('pre').forEach(pre => {
                                if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                    const codeText = pre.textContent;
                                    if (codeText && codeText.trim().startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) {
                                        pre.outerHTML = renderCodeBlock(codeText);
                                    }
                                }
                            });
                            addCopyButtonsTo(state.contentDiv);
                        }
                    }

                    const container = key.startsWith('ai') ? ui.chatContainerAI : ui.chatContainer;
                    if (container && container.scrollHeight - container.scrollTop - container.clientHeight < 150) {
                        container.scrollTop = container.scrollHeight;
                    }
                }

                if (state.ended && state.textBuffer.length === 0) {
                    finalizeStream(key);
                }
            }

            if (!anyActiveStreams) {
                if (renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            }
        }

        function finalizeStream(target, isError = false) {
            if (!target || !streamingState[target]) {
                console.warn('Attempt to finalize invalid stream target');
                return;
            }

            const state = streamingState[target];
            if (!state.active) return;

            const isThought = target.endsWith('thoughts');
            if (!isThought) removeThinkingBubble();

            if (state.contentDiv && state.textBuffer.length > 0) {
                state.currentText += state.textBuffer;
                state.textBuffer = '';
                const text = state.currentText.trim();

                if (state.contentDiv) {
                    try {
                        state.contentDiv.innerHTML = marked.parse(text);
                    } catch (e) {
                        console.error('Markdown parsing error in finalizeStream', e, text);
                        state.contentDiv.textContent = text;
                    }

                    if (!isThought) {
                        state.contentDiv.querySelectorAll('pre:not(.line-numbers pre):not(.code-content pre)').forEach(pre => {
                            if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                const codeText = pre.textContent.replace('Copy', '').trim();
                                if (codeText && codeText.startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) {
                                    pre.outerHTML = renderCodeBlock(codeText);
                                }
                            }
                        });

                        addCopyButtonsTo(state.contentDiv);
                    }
                }

                if (!isError && text.length > 0) {
                    const history = target.startsWith('ai') ? aiChatHistory : pdfChatHistory;
                    const lastMsg = history.length > 0 ? history[history.length - 1] : null;

                    if (!lastMsg || lastMsg.sender !== 'ai' || lastMsg.text !== text) {
                        history.push({ sender: 'ai', text, imageB64: null });
                        autosaveChat();
                    }
                }
            } else if (state.summary) {
                state.summary.textContent = 'View Thinking Process (Finished)';
            } else if (!isThought && !isError && state.currentText.length > 0) {
                const history = target.startsWith('ai') ? aiChatHistory : pdfChatHistory;
                const lastMsg = history.length > 0 ? history[history.length - 1] : null;

                if (!lastMsg || lastMsg.sender !== 'ai' || lastMsg.text !== state.currentText) {
                    history.push({ sender: 'ai', text: state.currentText, imageB64: null });
                    autosaveChat();
                }
            }

            cleanupStreaming(target);

            const mainChatKey = activeTab === 'aichat' ? 'aichat' : 'pdfchat';
            const thoughtKey = activeTab === 'aichat' ? 'aithoughts' : 'pdfthoughts';

            const mainStreamInactive = !streamingState[mainChatKey] || !streamingState[mainChatKey].active;
            const thoughtStreamInactive = !streamingState[thoughtKey] || !streamingState[thoughtKey].active;

            if (mainStreamInactive && thoughtStreamInactive && !isError) {
                console.log('Both streams for activeTab finished. Resetting UI state.');
                const currentStatusText = ui.status.textContent;

                if (!currentStatusText.includes('Processing')) {
                    console.log('Resetting UI state as no PDF processing is active.');

                    if (currentPDFName && activeTab === 'pdfchat') {
                        setUIState('readytochat', `Ready: ${currentPDFName}`);
                    } else {
                        setUIState('workerready', 'AI worker connected.');
                    }
                } else {
                    console.log('Streams finished, but PDF processing is active. Not resetting UI state yet.');
                }
            } else if (isError) {
                console.log('Error occurred during stream, UI state handled by error case.');
            } else {
                console.log('Stream target finished, but other streams for activeTab might still be active. Not resetting UI state yet.');
            }
        }

        function cleanupStreaming(target = null) {
            if (!target) {
                removeThinkingBubble();
                Object.keys(streamingState).forEach(key => {
                    if (streamingState[key]) {
                        streamingState[key] = {
                            active: false,
                            bubble: null,
                            contentDiv: null,
                            summary: null,
                            ended: false,
                            textBuffer: '',
                            currentText: '',
                            isCode: false,
                        };
                    }
                });

                if (renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            } else if (streamingState[target]) {
                streamingState[target] = {
                    active: false,
                    bubble: null,
                    contentDiv: null,
                    summary: null,
                    ended: false,
                    textBuffer: '',
                    currentText: '',
                    isCode: false,
                };

                let anyActive = Object.values(streamingState).some(ss => ss?.active);
                if (!anyActive && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                    console.log('All streams inactive, clearing render interval.');
                }
            }
        }

        function showRetryButton(tab, errorMsg) {
            const errorContainer = tab === 'pdfchat' ? ui.errorRetryContainerPdf : ui.errorRetryContainerAi;
            const targetChatContainer = tab === 'pdfchat' ? ui.chatContainer : ui.chatContainerAI;

            removeThinkingBubble();
            errorContainer.innerHTML = '';

            const existingErrorBubbles = targetChatContainer.querySelectorAll('.error-bubble-container');
            existingErrorBubbles.forEach(b => b.remove());

            const errorBubbleContainer = document.createElement('div');
            errorBubbleContainer.className = 'error-bubble-container flex justify-start mb-2 px-4 w-full';

            const displayError = String(errorMsg).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            errorBubbleContainer.innerHTML = `<div class="chat-bubble bg-red-600 text-white p-3 rounded-lg ai-bubble">ERROR: ${displayError}</div>`;
            targetChatContainer.appendChild(errorBubbleContainer);

            errorContainer.style.display = 'flex';
            errorContainer.innerHTML = '<button id="retry-button-' + tab + '" class="retry-button">Retry Last Prompt</button>';

            const retryButton = document.getElementById('retry-button-' + tab);
            if (retryButton) {
                retryButton.onclick = () => retryLastMessage(tab);
            }

            targetChatContainer.scrollTop = targetChatContainer.scrollHeight;
        }

        function retryLastMessage(tab) {
            if (!lastUserMessageText && !lastUserMessageImageB64) return;

            const chatContainer = tab === 'pdfchat' ? ui.chatContainer : ui.chatContainerAI;
            const errorBubbles = chatContainer.querySelectorAll('.error-bubble-container');
            errorBubbles.forEach(b => b.remove());

            ui.errorRetryContainerPdf.style.display = 'none';
            ui.errorRetryContainerAi.style.display = 'none';

            sendMessage(lastUserMessageText, tab, lastUserMessageImageB64, true);
        }

        async function autosaveChat() {
            const token = localStorage.getItem('aitoolkit:token');
            const historyToSave = activeTab === 'aichat' ? aiChatHistory : pdfChatHistory;

            if (!historyToSave || historyToSave.length === 0) return;

            const validHistory = historyToSave.filter(msg => msg && msg.sender && typeof msg.text === 'string');
            if (validHistory.length === 0) return;

            const firstUserMessage = validHistory.find(m => m.sender === 'user')?.text || 'New Chat';
            let chatId = activeTab === 'aichat' ? sessionStorage.getItem('currentAIChatId') : sessionStorage.getItem('currentPdfChatId');

            if (!chatId) {
                chatId = 'chat' + Date.now();
                if (activeTab === 'aichat') {
                    sessionStorage.setItem('currentAIChatId', chatId);
                } else {
                    sessionStorage.setItem('currentPdfChatId', chatId);
                }
            }

            const chatName = activeTab === 'pdfchat' && currentPDFName
                ? currentPDFName.replace('.pdf', '')
                : firstUserMessage.substring(0, 30);

            const chatData = {
                id: chatId,
                name: chatName,
                type: activeTab,
                timestamp: new Date().toISOString(),
                history: validHistory,
                pdfName: activeTab === 'pdfchat' ? currentPDFName : null,
            };

            if (token) {
                try {
                    await fetchWithAuth(`${RENDERAPIBASEURL}/chats`, {
                        method: 'POST',
                        body: JSON.stringify(chatData),
                    });
                    console.log('Chat saved to backend', chatId);
                } catch (error) {
                    // Error already logged
                }
            } else {
                const storageKey = guestId + ':' + chatId;
                try {
                    localStorage.setItem(storageKey, JSON.stringify(chatData));
                    console.log('Guest chat saved locally', storageKey);
                } catch (e) {
                    console.warn('Could not save guest chat to localStorage', e.message);
                }
            }
        }

async function loadSavedChats() {
    const token = localStorage.getItem('aitoolkit:token');
    ui.sidebarTitle.textContent = activeTab === 'pdfchat' ? 'Saved PDF Chats' : 'Saved AI Chats';
    ui.savedChatsList.innerHTML = '<p class="text-slate-400 text-sm px-2">Loading...</p>';

    let chats = [];

    try {
        if (token) {
            const response = await fetchWithAuth(`${RENDERAPIBASEURL}/chats`);
            const fetchedChats = Array.isArray(response) ? response : (response.chats || response.data || []);
            // FIX: Don't filter by type - show all chats
            chats = fetchedChats ? fetchedChats.filter(chat => chat && chat.id) : [];
            console.log('Fetched chats from backend:', chats.length, 'Total in response:', fetchedChats.length);
        } else {
            // guest mode code here...

                    try {
                        const guestIdVal = localStorage.getItem('aitoolkit:userid');
                        if (guestIdVal) {
                            for (let i = 0; i < localStorage.length; i++) {
                                const key = localStorage.key(i);
                                if (key.startsWith(guestIdVal + ':chat')) {
                                    try {
                                        const chat = JSON.parse(localStorage.getItem(key));
                                        if (chat.type === activeTab) {
                                            chats.push(chat);
                                        }
                                    } catch (e) {
                                        console.error('Error parsing localStorage key', key, e);
                                        localStorage.removeItem(key);
                                    }
                                }
                            }
                        }
                        console.log('Loaded guest chats from localStorage', chats.length);
                    } catch (e) {
                        console.warn('Could not load guest chats from localStorage', e.message);
                    }
                }
            } catch (error) {
                ui.savedChatsList.innerHTML = '<p class="text-red-400 text-sm px-2">Error loading chats.</p>';
                return;
            }

            if (chats.length === 0) {
                ui.savedChatsList.innerHTML = '<p class="text-slate-400 text-sm px-2">No saved chats yet.</p>';
                return;
            }

            ui.savedChatsList.innerHTML = '';
            chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(chat => {
                if (!chat || !chat.id) return;

                const item = document.createElement('div');
                item.className = 'sidebar-chat-item p-2 bg-slate-700 rounded-md cursor-pointer hover:bg-slate-600 truncate flex justify-between items-center text-sm';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = chat.name;
                nameSpan.className = 'overflow-hidden text-ellipsis whitespace-nowrap flex-grow mr-2';
                item.appendChild(nameSpan);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-chat-btn flex-shrink-0';
                deleteBtn.innerHTML = '√ó';

                const identifier = token ? chat.id : guestId + ':' + chat.id;

                item.onclick = () => loadChat(identifier);
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (window.confirm(`Delete "${chat.name}"? This cannot be undone.`)) {
                        deleteChat(identifier);
                    }
                };

                item.appendChild(deleteBtn);
                ui.savedChatsList.appendChild(item);
            });
        }

        async function loadChat(identifier) {
            const token = localStorage.getItem('aitoolkit:token');
            let chatData = null;
            const chatIdToLoad = token ? identifier : identifier.split(':').pop();

            console.log('Loading chat identifier ID', chatIdToLoad);

            cleanupStreaming();

            try {
                if (token) {
                    chatData = await fetchWithAuth(`${RENDERAPIBASEURL}/chats/${chatIdToLoad}`);
                } else {
                    try {
                        chatData = JSON.parse(localStorage.getItem(identifier));
                    } catch (e) {
                        console.warn('Could not load guest chat from localStorage', e.message);
                        throw new Error('Could not load chat data (localStorage blocked?).');
                    }
                }

                if (!chatData) {
                    throw new Error('Chat data not found.');
                }

                if (!chatData.history || !Array.isArray(chatData.history)) {
                    console.warn('Loaded chat data missing or invalid history array', chatData);
                    chatData.history = [];
                }

                activeTab = chatData.type;
                const currentChatIdKey = activeTab === 'aichat' ? 'currentAIChatId' : 'currentPdfChatId';
                sessionStorage.setItem(currentChatIdKey, chatData.id);

                if (activeTab === 'pdfchat') {
                    ui.viewChatPDF.style.display = 'grid';
                    ui.viewAIChat.style.display = 'none';
                    ui.tabChatPDF.classList.add('active');
                    ui.tabAIChat.classList.remove('active');

                    pdfChatHistory = chatData.history;
                    currentPDFName = chatData.pdfName;
                    renderHistory(pdfChatHistory, 'pdfchat');
                    ui.pdfTitle.textContent = currentPDFName || 'PDF Preview';
                    ui.pdfViewer.src = '';

                    if (!currentPDFName) {
                        addMessage('Chat loaded. Please re-upload ' + currentPDFName + ' to continue.', 'system', 'pdfchat');
                        setUIState('workerready', `Loaded ${currentPDFName}. Re-upload needed.`);
                    } else {
                        setUIState('workerready', 'AI worker connected.');
                    }
                } else {
                    ui.viewChatPDF.style.display = 'none';
                    ui.viewAIChat.style.display = 'flex';
                    ui.tabChatPDF.classList.remove('active');
                    ui.tabAIChat.classList.add('active');

                    aiChatHistory = chatData.history;
                    renderHistory(aiChatHistory, 'aichat');
                    setUIState('workerready', 'AI worker connected.');
                }

                ui.sidebar.classList.add('-translate-x-full');
            } catch (error) {
                console.error('Failed to load chat', error);
                addMessage(`Error: Could not load chat. ${error.message}`, 'system', activeTab);
            }
        }

        async function deleteChat(identifier) {
            const token = localStorage.getItem('aitoolkit:token');
            const chatIdToDelete = token ? identifier : identifier.split(':').pop();

            try {
                if (token) {
                    await fetchWithAuth(`${RENDERAPIBASEURL}/chats/${chatIdToDelete}`, {
                        method: 'DELETE',
                    });
                    console.log('Chat deleted from backend', chatIdToDelete);
                } else {
                    try {
                        localStorage.removeItem(identifier);
                        console.log('Guest chat deleted locally', identifier);
                    } catch (e) {
                        console.warn('Could not delete guest chat from localStorage', e.message);
                        addMessage('Could not delete chat (localStorage blocked?).', 'system', activeTab);
                    }
                }

                const currentChatIdKey = activeTab === 'aichat' ? 'currentAIChatId' : 'currentPdfChatId';
                const currentChatId = sessionStorage.getItem(currentChatIdKey);

                if (currentChatId === chatIdToDelete) {
                    startNewChat();
                } else {
                    loadSavedChats();
                }
            } catch (error) {
                // Error already logged
            }
        }

        function startNewChat() {
            const currentChatIdKey = activeTab === 'aichat' ? 'currentAIChatId' : 'currentPdfChatId';
            sessionStorage.removeItem(currentChatIdKey);

            if (activeTab === 'pdfchat') {
                pdfChatHistory = [];
                currentPDFName = null;
                ui.chatContainer.innerHTML = '';
                ui.pdfTitle.textContent = 'PDF Preview';
                ui.pdfViewer.src = '';
            } else {
                aiChatHistory = [];
                ui.chatContainerAI.innerHTML = '';
            }

            cleanupStreaming();
            ui.messageInput.value = '';
            ui.messageInputAI.value = '';
            ui.imagePreviewContainerAI.style.display = 'none';
            ui.imageUploadAI.value = '';
            uploadedImageB64 = null;

            ui.errorRetryContainerPdf.style.display = 'none';
            ui.errorRetryContainerAi.style.display = 'none';

            checkWorkerStatus();
            loadSavedChats();
        }

        function renderHistory(history, target) {
            const container = target === 'aichat' ? ui.chatContainerAI : ui.chatContainer;
            container.innerHTML = '';

            if (!history || history.length === 0) return;

            history.forEach(msg => {
                if (!msg || !msg.sender) return;

                const bubble = document.createElement('div');

                if (msg.sender === 'system') {
                    bubble.classList.add('text-center', 'text-xs', 'text-slate-400', 'my-2', 'px-4');
                    bubble.textContent = msg.text;
                } else {
                    bubble.classList.add('chat-bubble', 'p-3', 'w-fit', 'my-1');

                    if (msg.sender === 'user') {
                        bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                    } else {
                        bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                    }

                    const textNode = document.createElement('div');

                    if (msg.sender === 'ai') {
                        let finalHtml = '';
                        try {
                            finalHtml = marked.parse(msg.text);
                        } catch (e) {
                            console.error('Markdown parsing error', e);
                            finalHtml = msg.text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        }

                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = finalHtml;

                        tempDiv.querySelectorAll('pre:not(.line-numbers pre):not(.code-content pre)').forEach(pre => {
                            if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                const codeText = pre.textContent.replace('Copy', '').trim();
                                if (codeText && codeText.startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) {
                                    pre.outerHTML = renderCodeBlock(codeText);
                                }
                            }
                        });

                        textNode.innerHTML = tempDiv.innerHTML;
                        setTimeout(() => addCopyButtonsTo(bubble), 10);
                    } else {
                        textNode.textContent = msg.text;
                    }

                    bubble.appendChild(textNode);

                    if (msg.sender === 'user' && msg.imageB64) {
                        const img = document.createElement('img');
                        img.src = 'data:image/jpeg;base64,' + msg.imageB64;
                        img.className = 'mt-2 rounded max-w-xs';
                        bubble.appendChild(img);
                    }
                }

                container.appendChild(bubble);
            });

            requestAnimationFrame(() => {
                if (container) container.scrollTop = container.scrollHeight;
            });
        }

        function renderCodeBlock(codeText) {
            const lines = codeText.trim().split('\n');
            const langMatch = lines[0].match(/```(\w+)/);
            const language = langMatch ? langMatch[1] : '';
            const codeLines = langMatch ? lines.slice(1, lines.length - 1) : lines.slice(0);

            const escapeHtml = str => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const codeHtml = codeLines.map(line => `<code>${escapeHtml(line)}</code>`).join('\n');
            const lineNumbers = codeLines.map((_, index) => `<pre>${index + 1}</pre>`).join('\n');

            return `
                <div class="code-block-container">
                    ${language ? `<span class="language-tag">${language}</span>` : ''}
                    <ol>
                        <li class="line-numbers">${lineNumbers}</li>
                        <li class="code-content">${codeHtml}</li>
                    </ol>
                    <button class="copy-button">Copy</button>
                </div>
            `;
        }

        function addCopyButtonsTo(containerElement) {
            containerElement.querySelectorAll('.code-block-container').forEach(blockContainer => {
                if (blockContainer.querySelector('.copy-button.attached')) return;

                const codeElement = blockContainer.querySelector('.code-content');
                if (!codeElement) return;

                const button = blockContainer.querySelector('.copy-button');
                if (button) {
                    button.classList.add('attached');
                    button.addEventListener('click', () => {
                        const code = codeElement.innerText;
                        const textArea = document.createElement('textarea');
                        textArea.value = code;
                        document.body.appendChild(textArea);
                        textArea.select();

                        try {
                            document.execCommand('copy');
                            button.textContent = 'Copied!';
                        } catch (err) {
                            console.error('Fallback: unable to copy', err);
                            button.textContent = 'Error';
                        }

                        document.body.removeChild(textArea);
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                }
            });

            containerElement.querySelectorAll('pre').forEach(block => {
                if (block.closest('.code-block-container')) return;
                if (block.querySelector('.copy-button.attached')) return;

                const button = document.createElement('button');
                button.className = 'copy-button attached';
                button.textContent = 'Copy';

                block.style.position = 'relative';
                block.appendChild(button);

                button.addEventListener('click', () => {
                    const code = block.innerText;
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();

                    try {
                        document.execCommand('copy');
                        button.textContent = 'Copied!';
                    } catch (err) {
                        console.error('Fallback: unable to copy', err);
                        button.textContent = 'Error';
                    }

                    document.body.removeChild(textArea);
                    setTimeout(() => {
                        button.textContent = 'Copy';
                    }, 2000);
                });
            });
        }

        ui.usernameInput.addEventListener('input', () => {
            ui.authSubmitButton.disabled = !ui.usernameInput.value.trim() || !ui.passwordInput.value.trim();
        });

        ui.passwordInput.addEventListener('input', () => {
            ui.authSubmitButton.disabled = !ui.usernameInput.value.trim() || !ui.passwordInput.value.trim();
        });

        ui.tabChatPDF.addEventListener('click', () => {
            if (activeTab === 'pdfchat') return;
            cleanupStreaming();
            activeTab = 'pdfchat';
            ui.viewChatPDF.style.display = 'grid';
            ui.viewAIChat.style.display = 'none';
            ui.tabChatPDF.classList.add('active');
            ui.tabAIChat.classList.remove('active');
            startNewChat();
            loadSavedChats();
        });

        ui.tabAIChat.addEventListener('click', () => {
            if (activeTab === 'aichat') return;
            cleanupStreaming();
            activeTab = 'aichat';
            ui.viewChatPDF.style.display = 'none';
            ui.viewAIChat.style.display = 'flex';
            ui.tabChatPDF.classList.remove('active');
            ui.tabAIChat.classList.add('active');
            startNewChat();
            loadSavedChats();
        });

        ui.openSidebarButton.addEventListener('click', () => {
            loadSavedChats();
            ui.sidebar.classList.remove('-translate-x-full');
        });

        ui.closeSidebarButton.addEventListener('click', () => {
            ui.sidebar.classList.add('-translate-x-full');
        });

        ui.newChatButton.addEventListener('click', () => {
            startNewChat();
            ui.sidebar.classList.add('-translate-x-full');
        });

        ui.pdfUploadInput.addEventListener('change', uploadPDF);
        ui.imageUploadAI.addEventListener('change', (e) => handleImageFile(e.target.files[0]));
        ui.removeImageButtonAI.addEventListener('click', () => {
            uploadedImageB64 = null;
            ui.imagePreviewContainerAI.style.display = 'none';
            ui.imageUploadAI.value = '';
        });

        ui.messageInputAI.addEventListener('paste', (e) => {
            const items = e.clipboardData || window.clipboardData;
            for (const item of items.items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    handleImageFile(file);
                    return;
                }
            }
        });

        ui.sendButton.addEventListener('click', () => sendMessage(ui.messageInput.value, 'pdfchat'));
        ui.messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(ui.messageInput.value, 'pdfchat');
            }
        });

        ui.sendButtonAI.addEventListener('click', () => sendMessage(ui.messageInputAI.value, 'aichat', uploadedImageB64));
        ui.messageInputAI.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(ui.messageInputAI.value, 'aichat', uploadedImageB64);
            }
        });

        ui.fastModeButtonPdf.addEventListener('click', () => toggleFastMode(ui.fastModeButtonPdf));
        ui.fastModeButtonAi.addEventListener('click', () => toggleFastMode(ui.fastModeButtonAi));

        ui.authForm.addEventListener('submit', handleAuthSubmit);
        ui.logoutButton.addEventListener('click', handleLogout);
        ui.loginButton.addEventListener('click', () => {
            isLoginMode = true;
            ui.authTitle.textContent = 'Login';
            ui.authSubmitButton.textContent = 'Login';
            ui.authSwitchButton.textContent = 'Need an account? Sign up';
            ui.authSubmitButton.disabled = true;
            showAuthModal(true);
        });

        ui.authCloseButton.addEventListener('click', () => showAuthModal(false));
        ui.authSwitchButton.addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            ui.authTitle.textContent = isLoginMode ? 'Login' : 'Sign Up';
            ui.authSubmitButton.textContent = isLoginMode ? 'Login' : 'Sign Up';
            ui.authSwitchButton.textContent = isLoginMode ? 'Need an account? Sign up' : 'Have an account? Login';
            ui.authError.style.display = 'none';
            ui.authForm.reset();
            ui.authSubmitButton.disabled = true;
        });

        async function uploadPDF() {
            const file = ui.pdfUploadInput.files[0];
            if (!file) return;

            startNewChat();
            currentPDFName = file.name;
            ui.pdfTitle.textContent = currentPDFName;
            ui.pdfViewer.src = URL.createObjectURL(file);
            setUIState('processing', `Processing ${file.name}...`);
            addMessage(`Uploading ${file.name}...`, 'system', 'pdfchat');

            let userid;
            const token = localStorage.getItem('aitoolkit:token');
            if (token) {
                const payload = JSON.parse(atob(token.split('.')[1]));
                userid = payload.sub;
            } else {
                userid = guestId;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch(`${RENDERAPIBASEURL}/upload?userid=${userid}`, {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch {
                        errorData = { detail: response.statusText };
                    }
                    throw new Error(errorData.detail || `Failed to start PDF processing. Worker will send Processing... status message`);
                }
            } catch (error) {
                addMessage(`Upload Error: ${error.message}`, 'system', 'pdfchat');
                setUIState('workerready', 'Upload failed.');
                currentPDFName = null;
                ui.pdfTitle.textContent = 'PDF Preview';
                ui.pdfViewer.src = '';
            }
        }

        function handleImageFile(file) {
            if (!file || !file.type.startsWith('image/')) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                uploadedImageB64 = event.target.result.split(',')[1];
                ui.imagePreviewAI.src = event.target.result;
                ui.imagePreviewContainerAI.style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        function toggleFastMode(button) {
            fastMode = !fastMode;
            [ui.fastModeButtonAi, ui.fastModeButtonPdf].forEach(btn => {
                btn.classList.toggle('fast-active', fastMode);
                btn.textContent = fastMode ? 'FAST MODE ACTIVE' : 'Fast Paste';
            });

            if (Object.values(streamingState).some(ss => ss?.active)) {
                if (renderInterval) clearInterval(renderInterval);
                renderInterval = setInterval(renderCharacters, fastMode ? 1 : RENDERSPEED);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            updateAuthUI();
            activeTab = 'pdfchat';
            ui.viewChatPDF.style.display = 'grid';
            ui.viewAIChat.style.display = 'none';
            ui.tabChatPDF.classList.add('active');
            ui.tabAIChat.classList.remove('active');

            checkWorkerStatus();
        });
    </script>
</body>
</html>


