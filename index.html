<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Toolkit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 90%; word-wrap: break-word; white-space: pre-wrap; }
        .user-bubble { background-color: #2563eb; color: white; }
        .ai-bubble { background-color: #334155; color: #f1f5f9; }
        
        /* --- STYLES FOR AUTH MODAL --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        .modal-content {
            background-color: #1e293b;
            padding: 2rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 400px;
            color: white;
        }

        /* --- STYLES FOR THOUGHTS BUBBLE --- */
        .thoughts-bubble { 
            background-color: #1e293b; 
            color: #94a3b8; 
            font-size: 0.9rem;
            border-left: 3px solid #6366f1;
            padding: 0.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .thoughts-bubble details > summary {
            list-style: none;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            outline: none;
            color: #a5b4fc;
            font-weight: 600;
        }
        .thoughts-bubble details[open] > summary {
            border-bottom: 1px solid #475569;
            margin-bottom: 0.5rem;
        }
        .thoughts-content pre { 
            background-color: #0f172a; 
            padding: 0.75rem; 
            border-radius: 0.375rem; 
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        /* --- STYLES FOR SPEED BUTTON --- */
        .speed-button {
            background-color: #6366f1;
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            opacity: 0.8;
            font-weight: 600;
        }
        .speed-button:hover {
            opacity: 1;
            background-color: #4f46e5;
        }
        .speed-button.fast-active {
            background-color: #f59e0b;
        }

        /* --- STYLES FOR CODE BLOCK WITH LINE NUMBERS --- */
        .code-block-container {
            position: relative;
            background-color: #0f172a;
            border-radius: 0.5rem;
            margin: 1rem 0;
            padding: 0;
            overflow: hidden;
        }
        .code-block-container .language-tag {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #475569;
            color: #e2e8f0;
            padding: 0.1rem 0.5rem;
            font-size: 0.7rem;
            border-top-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            z-index: 10;
        }
        .code-block-container ol {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            font-size: 0.9rem;
        }
        .line-numbers {
            background-color: #1e293b;
            color: #64748b;
            text-align: right;
            padding: 1rem 0.5rem;
            user-select: none;
            line-height: 1.5;
        }
        .code-content {
            flex-grow: 1;
            padding: 1rem;
            overflow-x: auto;
        }
        .code-content code {
            display: block;
            white-space: pre;
            color: #e2e8f0;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
        }
        
        /* --- STYLES FOR RETRY BUTTON --- */
        .retry-button {
            background-color: #dc2626; /* Red-600 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 600;
            margin-top: 1rem;
            transition: background-color 0.2s;
        }
        .retry-button:hover {
            background-color: #b91c1c; /* Red-700 */
        }

        #error-retry-container-pdf, 
        #error-retry-container-ai {
            display: flex;
            justify-content: center;
            padding: 1rem;
        }

        #chat-sidebar { transition: transform 0.3s ease-in-out; }
        .tab-button.active { border-color: #4f46e5; color: #4f46e5; }
        

        #chat-container::-webkit-scrollbar,
        #chat-container-ai::-webkit-scrollbar,
        #saved-chats-list::-webkit-scrollbar { width: 8px; }

        #chat-container::-webkit-scrollbar-track,
        #chat-container-ai::-webkit-scrollbar-track,
        #saved-chats-list::-webkit-scrollbar-track { background: #1e293b; }

        #chat-container::-webkit-scrollbar-thumb,
        #chat-container-ai::-webkit-scrollbar-thumb,
        #saved-chats-list::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        

        .ai-bubble pre { background-color: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; position: relative; }
        .ai-bubble code { font-family: 'Courier New', Courier, monospace; }
        .user-bubble img { max-width: 150px; border-radius: 0.5rem; margin-top: 0.5rem; }

        .copy-button { position: absolute; top: 0.5rem; right: 0.5rem; background-color: #475569; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.8rem; opacity: 0; transition: opacity 0.2s; }
        pre:hover .copy-button { opacity: 1; }

        .ai-bubble table { width: 100%; margin-top: 1em; margin-bottom: 1em; border-collapse: collapse; border: 1px solid #475569; }
        .ai-bubble th, .ai-bubble td { border: 1px solid #475569; padding: 0.5rem 0.75rem; text-align: left; }
        .ai-bubble th { background-color: #1e293b; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div id="auth-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="auth-title" class="text-2xl font-bold mb-4">Login</h2>
            <div id="auth-error" class="text-red-400 mb-2" style="display: none;"></div>
            <form id="auth-form">
                <div class="mb-4">
                    <label for="username" class="block mb-1">Username</label>
                    <input type="text" id="username" class="w-full bg-slate-700 border border-slate-600 rounded p-2" required>
                </div>
                <div class="mb-6">
                    <label for="password" class="block mb-1">Password</label>
                    <input type="password" id="password" class="w-full bg-slate-700 border border-slate-600 rounded p-2" required>
                </div>
                <div class="flex justify-between items-center">
                    <div>
                        <button type="submit" id="auth-submit-button" class="bg-indigo-500 hover:bg-indigo-600 px-4 py-2 rounded">Login</button>
                        <button type="button" id="auth-close-button" class="text-slate-400 hover:text-white ml-2">Cancel</button>
                    </div>
                    <button type="button" id="auth-switch-button" class="text-sm text-indigo-400 hover:underline">Need an account? Sign up</button>
                </div>
            </form>
        </div>
    </div>

    <div class="flex h-full">

        <aside id="chat-sidebar" class="w-64 bg-slate-800 text-white
        flex flex-col p-4 transform -translate-x-full fixed h-full z-20">
            <div class="flex justify-between items-center mb-4 border-b border-slate-600 pb-2">
                <h2 id="sidebar-title" class="text-xl font-bold">Saved Chats</h2>
                <button id="close-sidebar-button" class="text-slate-400 hover:text-white text-2xl">&times;</button>
            </div>
            <div id="user-status" class="text-center text-sm text-slate-400 mb-2">Guest Mode</div>
            <button id="new-chat-button" class="w-full text-left p-2 mb-2 bg-indigo-500 rounded-md hover:bg-indigo-600">Ôºã New Chat</button>
            <div id="saved-chats-list" class="flex-1 overflow-y-auto space-y-2"></div>
        </aside>

        <div class="flex-1 flex flex-col h-full">
            <header class="bg-white shadow-md p-4 flex items-center justify-between z-10">
                <div class="flex items-center space-x-4">
                    <button id="open-sidebar-button" class="p-2 rounded-md hover:bg-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                    </button>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-800">AI Toolkit</h1>
                        <p id="status" class="text-sm text-gray-500">Status: Connecting to server...</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="tab-chatpdf" class="tab-button py-2 px-4 text-gray-500 font-semibold border-b-2">ChatPDF</button>
                    <button id="tab-ai-chat" class="tab-button py-2 px-4 text-gray-500 font-semibold border-b-2">AI Chat</button>
                    <button id="login-button" class="bg-indigo-500 text-white px-4 py-2 rounded-md hover:bg-indigo-600">Login / Sign Up</button>
                    <button id="logout-button" class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600" style="display: none;">Logout</button>
                </div>
            </header>

            <div id="view-chatpdf" class="flex-1 grid grid-cols-2 gap-4 p-4 overflow-hidden">
                <section class="bg-white rounded-lg shadow-md flex flex-col h-full">
                    <div class="p-2 border-b bg-gray-50"><h2 id="pdf-title" class="text-lg font-bold text-gray-700 truncate">PDF Preview</h2></div>
                    <div class="flex-1 p-2"><embed id="pdf-viewer" src="" type="application/pdf" width="100%" height="100%"/></div>
                </section>
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <div id="error-retry-container-pdf" class="bg-slate-800" style="display: none;"></div>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">
                            <label for="pdf-upload" id="upload-label" class="cursor-not-allowed bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">üìÅ Upload</label>
                            <input id="pdf-upload" type="file" class="hidden" accept=".pdf" disabled>
                            <button id="fast-mode-button-pdf" class="speed-button">‚ö° Fast Paste</button>
                            <input type="text" id="message-input" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2" placeholder="Please connect to worker..." disabled>
                            <button id="send-button" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>

            <div id="view-ai-chat" style="display: none;" class="flex-1 flex flex-col p-4 overflow-hidden">
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container-ai" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <div id="image-preview-container-ai" class="p-4 pt-0" style="display: none;">
                        <div class="relative w-24 h-24">
                            <img id="image-preview-ai" class="w-full h-full object-cover rounded-md">
                            <button id="remove-image-button-ai" class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center -mt-2 -mr-2">&times;</button>
                        </div>
                    </div>
                    <div id="error-retry-container-ai" class="bg-slate-800" style="display: none;"></div>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">
                            <label for="image-upload-ai" class="cursor-pointer text-slate-400 hover:text-white p-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                            </label>
                            <input id="image-upload-ai" type="file" class="hidden" accept="image/jpeg,image/png">
                            <button id="fast-mode-button-ai" class="speed-button">‚ö° Fast Paste</button>
                            <input type="text" id="message-input-ai" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2" placeholder="Please connect to worker..." disabled>
                            <button id="send-button-ai" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                status: document.getElementById('status'),
                sidebar: document.getElementById('chat-sidebar'),
                sidebarTitle: document.getElementById('sidebar-title'),
                openSidebarButton: document.getElementById('open-sidebar-button'),
                closeSidebarButton: document.getElementById('close-sidebar-button'),
                newChatButton: document.getElementById('new-chat-button'),
                savedChatsList: document.getElementById('saved-chats-list'),
                
                tabChatPDF: document.getElementById('tab-chatpdf'),
                tabAIChat: document.getElementById('tab-ai-chat'),
                viewChatPDF: document.getElementById('view-chatpdf'),
                viewAIChat: document.getElementById('view-ai-chat'),

                chatContainer: document.getElementById('chat-container'),
                messageInput: document.getElementById('message-input'),
                sendButton: document.getElementById('send-button'),
                pdfUploadInput: document.getElementById('pdf-upload'),
                uploadLabel: document.getElementById('upload-label'),
                pdfViewer: document.getElementById('pdf-viewer'),
                pdfTitle: document.getElementById('pdf-title'),

                chatContainerAI: document.getElementById('chat-container-ai'),
                messageInputAI: document.getElementById('message-input-ai'),
                sendButtonAI: document.getElementById('send-button-ai'),
                imageUploadAI: document.getElementById('image-upload-ai'),
                imagePreviewContainerAI: document.getElementById('image-preview-container-ai'),
                imagePreviewAI: document.getElementById('image-preview-ai'),
                removeImageButtonAI: document.getElementById('remove-image-button-ai'),
                
                fastModeButtonPdf: document.getElementById('fast-mode-button-pdf'),
                fastModeButtonAi: document.getElementById('fast-mode-button-ai'),
                
                errorRetryContainerPdf: document.getElementById('error-retry-container-pdf'),
                errorRetryContainerAi: document.getElementById('error-retry-container-ai'),
                
                authModal: document.getElementById('auth-modal'),
                authTitle: document.getElementById('auth-title'),
                authError: document.getElementById('auth-error'),
                authForm: document.getElementById('auth-form'),
                authSubmitButton: document.getElementById('auth-submit-button'),
                authCloseButton: document.getElementById('auth-close-button'),
                authSwitchButton: document.getElementById('auth-switch-button'),
                loginButton: document.getElementById('login-button'),
                logoutButton: document.getElementById('logout-button'),
                userStatus: document.getElementById('user-status'),
                usernameInput: document.getElementById('username'),
                passwordInput: document.getElementById('password')
            };
            
            let pdfChatHistory = [];
            let aiChatHistory = [];
            let currentPDFName = null;
            let activeTab = 'pdf_chat';
            let uploadedImageB64 = null;
            
            let fastMode = false; 
            
            let lastUserMessageText = null; 
            let lastUserMessageImageB64 = null; 
            
            let isLoginMode = true;

            let socket, statusInterval, pingInterval;
            
            let streamingState = {
                pdf_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                ai_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                pdf_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' },
                ai_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' }
            };

            let renderInterval = null;
            const RENDER_SPEED = 10; 
            const CHARS_PER_TICK = 3;
            
            // --- AUTHENTICATION LOGIC ---
            function showAuthModal(show) {
                ui.authModal.style.display = show ? 'flex' : 'none';
                if (!show) {
                    ui.authError.style.display = 'none';
                    ui.authForm.reset();
                }
            }
            
            function updateAuthUI() {
                const token = sessionStorage.getItem('ai_toolkit_token');
                if (token) {
                    try {
                        const payload = JSON.parse(atob(token.split('.')[1]));
                        ui.userStatus.textContent = `Logged in: ${payload.sub}`;
                        ui.loginButton.style.display = 'none';
                        ui.logoutButton.style.display = 'block';
                    } catch (e) {
                        handleLogout(); // Invalid token
                    }
                } else {
                    ui.userStatus.textContent = 'Guest Mode';
                    ui.loginButton.style.display = 'block';
                    ui.logoutButton.style.display = 'none';
                }
            }
            
            async function handleAuthSubmit(event) {
                event.preventDefault();
                const username = ui.usernameInput.value.trim();
                const password = ui.passwordInput.value.trim();
                const endpoint = isLoginMode ? '/login' : '/signup';
                
                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.detail || 'An error occurred.');
                    }
                    
                    if (isLoginMode) {
                        sessionStorage.setItem('ai_toolkit_token', data.access_token);
                        showAuthModal(false);
                        updateAuthUI();
                        startNewChat(); // Start a fresh chat on login
                    } else {
                        // Switch to login mode after successful signup
                        isLoginMode = true;
                        ui.authTitle.textContent = 'Login';
                        ui.authSubmitButton.textContent = 'Login';
                        ui.authSwitchButton.textContent = 'Need an account? Sign up';
                        ui.authError.style.display = 'block';
                        ui.authError.textContent = 'Signup successful! Please log in.';
                        ui.authForm.reset();
                    }
                } catch (error) {
                    ui.authError.style.display = 'block';
                    ui.authError.textContent = error.message;
                }
            }

            function handleLogout() {
                sessionStorage.removeItem('ai_toolkit_token');
                updateAuthUI();
                startNewChat(); // Start a fresh guest chat on logout
            }

            // Event Listeners for Auth UI
            ui.loginButton.addEventListener('click', () => showAuthModal(true));
            ui.authCloseButton.addEventListener('click', () => showAuthModal(false));
            ui.authSwitchButton.addEventListener('click', () => {
                isLoginMode = !isLoginMode;
                ui.authTitle.textContent = isLoginMode ? 'Login' : 'Sign Up';
                ui.authSubmitButton.textContent = isLoginMode ? 'Login' : 'Sign Up';
                ui.authSwitchButton.textContent = isLoginMode ? 'Need an account? Sign up' : 'Have an account? Login';
                ui.authError.style.display = 'none';
                ui.authForm.reset();
            });
            ui.authForm.addEventListener('submit', handleAuthSubmit);
            ui.logoutButton.addEventListener('click', handleLogout);

            // --- END AUTH LOGIC ---

            function renderCodeBlock(codeText) {
                const lines = codeText.trim().split('\n');
                const langMatch = lines[0].match(/```(\w+)/);
                const language = langMatch ? langMatch[1] : '';
                const codeLines = lines.slice(1, lines.length - 1).join('\n');
                const escapeHtml = (str) => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                const codeHtml = codeLines.split('\n').map(line => `<code>${escapeHtml(line)}</code>`).join('');
                const lineNumbers = codeLines.split('\n').map((_, index) => index + 1).join('\n');
                return `
                    <div class="code-block-container">
                        ${language ? `<span class="language-tag">${language}</span>` : ''}
                        <ol>
                            <li class="line-numbers"><pre>${lineNumbers}</pre></li>
                            <li class="code-content"><pre>${codeHtml}</pre></li>
                        </ol>
                        <button class="copy-button">Copy</button>
                    </div>
                `;
            }

            function setUIState(state, message = "") {
                ui.status.textContent = `Status: ${message}`;
                const isChatReady = state === 'ready_to_chat';
                const isWorkerReady = state === 'worker_ready' || isChatReady;
                
                ui.pdfUploadInput.disabled = !isWorkerReady;
                ui.uploadLabel.classList.toggle('cursor-not-allowed', !isWorkerReady);
                ui.uploadLabel.classList.toggle('cursor-pointer', isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-gray-500', !isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-blue-500', isWorkerReady);
                ui.uploadLabel.classList.toggle('hover:bg-blue-600', isWorkerReady);
                
                const isPdfStreaming = streamingState.pdf_chat.active || streamingState.pdf_thoughts.active;
                const isAiStreaming = streamingState.ai_chat.active || streamingState.ai_thoughts.active;

                ui.messageInput.disabled = !isChatReady || isPdfStreaming;
                ui.sendButton.disabled = !isChatReady || isPdfStreaming;
                ui.messageInputAI.disabled = !isWorkerReady || isAiStreaming;
                ui.sendButtonAI.disabled = !isWorkerReady || isAiStreaming;

                if (isChatReady && !isPdfStreaming) {
                    ui.messageInput.placeholder = "Ask a question about the PDF...";
                    ui.sendButton.classList.remove('bg-gray-500'); 
                    ui.sendButton.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInput.placeholder = message;
                    ui.sendButton.classList.add('bg-gray-500'); 
                    ui.sendButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                }

                if (isWorkerReady && !isAiStreaming) {
                    ui.messageInputAI.placeholder = "Send a message, or paste an image...";
                    ui.sendButtonAI.classList.remove('bg-gray-500'); 
                    ui.sendButtonAI.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInputAI.placeholder = message;
                    ui.sendButtonAI.classList.add('bg-gray-500'); 
                    ui.sendButtonAI.classList.remove('bg-green-500', 'hover:bg-green-600');
                }
            }

            async function checkWorkerStatus() {
                try {
                    const response = await fetch(`/status`);
                    if (!response.ok) throw new Error("Server not reachable");
                    const data = await response.json();
                    if (data.worker_connected) {
                        setUIState('worker_ready', 'AI worker connected. Authenticating...');
                        clearInterval(statusInterval);
                        connectWebSocket();
                    } else {
                        setUIState('waiting_for_worker', 'Waiting for local AI worker...');
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                    setUIState('error', 'Could not connect to server.');
                }
            }

            function connectWebSocket() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws/web`; // No user_id in URL
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log("WebSocket connected. Sending auth...");
                    const token = sessionStorage.getItem('ai_toolkit_token');
                    if (token) {
                        socket.send(JSON.stringify({ type: 'auth', token: token }));
                    } else {
                        // Guest user
                        const guestId = localStorage.getItem('ai_toolkit_user_id') || `user_${Math.random().toString(36).substr(2, 9)}`;
                        localStorage.setItem('ai_toolkit_user_id', guestId);
                        socket.send(JSON.stringify({ type: 'auth', user_id: guestId }));
                    }
                    
                    if (pingInterval) clearInterval(pingInterval);
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 20000);
                };

                socket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        if (message.type === 'auth_success') {
                            console.log("Authentication successful!");
                            if (currentPDFName) {
                                setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                            } else {
                                 setUIState('worker_ready', 'AI worker connected.');
                            }
                            return;
                        }
                        handleServerMessage(message);
                    } catch (error) {
                        console.error("‚ùå Failed to handle message:", error, event.data);
                    }
                };
                
                socket.onclose = (event) => {
                    clearInterval(pingInterval);
                    
                    const wasStreaming = streamingState.pdf_chat.active || streamingState.ai_chat.active;
                    const targetTab = activeTab;

                    cleanupStreaming();
                    
                    setUIState('disconnected', 'Disconnected. Trying to reconnect...');
                    if (statusInterval) clearInterval(statusInterval);
                    statusInterval = setInterval(checkWorkerStatus, 3000);

                    if (wasStreaming && lastUserMessageText) {
                        showRetryButton(targetTab, `Connection lost during response (Code ${event.code}). Please retry.`);
                    }
                };
                
                socket.onerror = (error) => {
                    console.error("‚ùå WebSocket Error:", error);
                };
            }

            function addCopyButtonsTo(containerElement) {
                containerElement.querySelectorAll('.code-block-container').forEach(blockContainer => {
                    if (blockContainer.querySelector('.copy-button.attached')) return;
                    const codeElement = blockContainer.querySelector('.code-content code');
                    if (!codeElement) return;
                    const button = blockContainer.querySelector('.copy-button');
                    button.classList.add('attached');
                    button.addEventListener('click', () => {
                        const code = codeElement.innerText;
                        navigator.clipboard.writeText(code).then(() => {
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    });
                });
                
                containerElement.querySelectorAll('pre').forEach(block => {
                    if (block.querySelector('.copy-button.attached')) return;
                    if (block.closest('.code-block-container')) return;
                    const button = document.createElement('button');
                    button.className = 'copy-button attached';
                    button.textContent = 'Copy';
                    block.appendChild(button);
                    button.addEventListener('click', () => {
                        const code = block.querySelector('code')?.innerText || block.innerText;
                        navigator.clipboard.writeText(code).then(() => {
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    });
                });
            }
            
            function addMessage(text, sender, target = 'pdf_chat', imageB64 = null) {
                const history = (target === 'ai_chat') ? aiChatHistory : pdfChatHistory;
                const container = target.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;
                
                if (target.endsWith('_thoughts')) {
                    const bubble = document.createElement('div');
                    bubble.classList.add('thoughts-bubble', 'w-full', 'self-start', 'mr-auto');
                    
                    const details = document.createElement('details');
                    details.classList.add('w-full');
                    
                    const summary = document.createElement('summary');
                    summary.textContent = '...AI is thinking... (Click to view)';
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.classList.add('thoughts-content', 'pt-2', 'pb-1');
                    
                    details.appendChild(summary);
                    details.appendChild(contentDiv);
                    bubble.appendChild(details);
                    
                    container.appendChild(bubble);
                    container.scrollTop = container.scrollHeight;
                    
                    return { bubble: bubble, contentDiv: contentDiv, summary: summary };
                }
                
                const bubble = document.createElement('div');
                bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                
                if (sender === 'user') {
                    bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                } else {
                    bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                }
                
                const textNode = document.createElement('div');
                textNode.textContent = text; 
                bubble.appendChild(textNode);
                
                if (sender === 'user' && imageB64) {
                    const img = document.createElement('img');
                    img.src = `data:image/jpeg;base64,${imageB64}`;
                    bubble.appendChild(img);
                }
                
                container.appendChild(bubble);
                container.scrollTop = container.scrollHeight;
                
                if (sender === 'user') {
                     history.push({ sender, text: text, imageB64: imageB64 });
                }
                
                return { bubble: bubble, contentDiv: textNode, summary: null };
            }
            
            function showRetryButton(tab, errorMsg) {
                const errorContainer = tab === 'pdf_chat' ? ui.errorRetryContainerPdf : ui.errorRetryContainerAi;
                const targetChatContainer = tab === 'pdf_chat' ? ui.chatContainer : ui.chatContainerAI;
                
                const errorBubble = document.createElement('div');
                errorBubble.className = 'flex justify-start mb-4 px-4 w-full';
                errorBubble.innerHTML = `<div class="chat-bubble bg-red-600 text-white p-3 rounded-lg ai-bubble">
                    **üö® ERROR**: The response failed. This often happens if the AI is processing for too long and the network times out. 
                    <br>Error details: <i>${errorMsg}</i>
                </div>`;
                targetChatContainer.appendChild(errorBubble);
                
                errorContainer.style.display = 'flex';
                errorContainer.innerHTML = `
                    <button id="retry-button-${tab}" class="retry-button">
                        ‚ôªÔ∏è Retry Last Prompt
                    </button>
                `;

                document.getElementById(`retry-button-${tab}`).onclick = () => retryLastMessage(tab);
                
                targetChatContainer.scrollTop = targetChatContainer.scrollHeight;
            }

            function retryLastMessage(tab) {
                if (!lastUserMessageText) return;

                ui.errorRetryContainerPdf.style.display = 'none';
                ui.errorRetryContainerAi.style.display = 'none';
                
                const history = tab === 'pdf_chat' ? pdfChatHistory : aiChatHistory;
                if (history.length > 0 && history[history.length - 1].sender !== 'user') {
                    history.pop();
                }
                
                sendMessage(lastUserMessageText, tab, lastUserMessageImageB64, true);
            }


            function handleServerMessage(message) {
                const targetKey = message.target || 'pdf_chat';
                const mainTarget = targetKey.endsWith('_thoughts') ? targetKey.replace('_thoughts', '_chat') : targetKey;

                switch (message.type) {
                    case 'status':
                        addMessage(message.data, 'ai', mainTarget);
                        if (message.data.includes("Ready for questions")) {
                            setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                        }
                        break;
                        
                    case 'answer_chunk':
                        if (!streamingState[targetKey].active) {
                            streamingState[targetKey].active = true;
                            streamingState[targetKey].ended = false;
                            streamingState[targetKey].textBuffer = ''; 
                            streamingState[targetKey].currentText = '';
                            streamingState[targetKey].isCode = false;

                            if (targetKey.endsWith('_thoughts')) {
                                const thoughtElements = addMessage('', 'ai', targetKey);
                                streamingState[targetKey].bubble = thoughtElements.bubble;
                                streamingState[targetKey].contentDiv = thoughtElements.contentDiv;
                                streamingState[targetKey].summary = thoughtElements.summary;
                                streamingState[mainTarget].active = true; 
                                setUIState('ai_thinking', 'AI is thinking...'); 
                            } else {
                                if (!streamingState[mainTarget.replace('_chat', '_thoughts')].active) {
                                    const answerElements = addMessage('', 'ai', targetKey);
                                    streamingState[targetKey].bubble = answerElements.bubble;
                                    streamingState[targetKey].contentDiv = answerElements.contentDiv;
                                }
                            }
                            
                            if (!renderInterval) { 
                                renderInterval = setInterval(() => renderCharacters(), RENDER_SPEED); 
                            }
                        }
                        
                        streamingState[targetKey].textBuffer += message.data;
                        break;
                        
                    case 'answer_end':
                        streamingState[targetKey].ended = true;
                        
                        if (targetKey.endsWith('_thoughts')) {
                             const state = streamingState[targetKey];
                             if (state.summary) {
                                state.summary.textContent = 'View Thinking Process (Finished)';
                             }
                        }
                        break;
                        
                    case 'error':
                        finalizeStream(mainTarget, true); 
                        showRetryButton(mainTarget, message.data);
                        cleanupStreaming(mainTarget.replace('_chat', '_thoughts'));
                        setUIState('worker_ready', 'Error occurred.');
                        break;
                        
                    case 'pong':
                        break;
                        
                    default:
                        console.warn("‚ö†Ô∏è Unknown message type:", message.type);
                }
            }
            
            function renderCharacters() { 
                const renderSpeed = fastMode ? 999999 : CHARS_PER_TICK; 
                
                for (let key in streamingState) {
                    const state = streamingState[key];
                    
                    if (state.active) {
                        
                        if (key.endsWith('_chat') && streamingState[key.replace('_chat', '_thoughts')].ended && !state.bubble) {
                            const answerElements = addMessage('', 'ai', key);
                            state.bubble = answerElements.bubble;
                            state.contentDiv = answerElements.contentDiv;
                        }

                        if (state.textBuffer.length > 0 || (state.ended && state.currentText.length > 0)) {
                            
                            const charsToRender = Math.min(state.textBuffer.length, renderSpeed);
                            const chunk = state.textBuffer.substring(0, charsToRender);
                            state.currentText += chunk;
                            state.textBuffer = state.textBuffer.substring(charsToRender);

                            if (state.contentDiv) {
                                
                                if (key.endsWith('_thoughts')) {
                                    state.contentDiv.innerHTML = marked.parse(state.currentText);
                                } else if (key.endsWith('_chat')) {
                                    
                                    const text = state.currentText;
                                    
                                    if (!state.isCode && text.includes('```')) {
                                        state.isCode = true;
                                    }
                                    
                                    if (state.isCode) {
                                        const tempHtml = marked.parse(text);
                                        state.contentDiv.innerHTML = tempHtml;
                                        
                                        const codeBlock = state.contentDiv.querySelector('pre');
                                        if (codeBlock && codeBlock.textContent.trim().startsWith('```')) {
                                            const codeText = codeBlock.textContent;
                                            codeBlock.outerHTML = renderCodeBlock(codeText);
                                        }

                                    } else {
                                        state.contentDiv.textContent = text;
                                    }
                                }
                                
                                const container = key.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;
                                container.scrollTop = container.scrollHeight;
                            }
                        }
                        
                        if (state.ended && state.textBuffer.length === 0) {
                            
                            if (key.endsWith('_thoughts')) {
                                finalizeStream(key);
                            } else if (key.endsWith('_chat')) {
                                const thoughtKey = key.replace('_chat', '_thoughts');
                                if (!streamingState[thoughtKey].active) {
                                    finalizeStream(key);
                                }
                            }
                        }
                    }
                }
                
                let anyActive = Object.values(streamingState).some(s => s.active);
                if (!anyActive && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            }
            
            function cleanupStreaming(target) {
                const targets = [target];
                if (target.endsWith('_chat')) {
                    targets.push(target.replace('_chat', '_thoughts'));
                }
                
                targets.forEach(key => {
                    if (streamingState[key]) {
                        streamingState[key] = { 
                            active: false, bubble: null, contentDiv: null, summary: null,
                            ended: false, textBuffer: '', currentText: '', isCode: false 
                        };
                    }
                });

                let anyActive = Object.values(streamingState).some(s => s.active);
                if (!anyActive && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            }
            
            function finalizeStream(target, isError = false) {
                const state = streamingState[target];
                if (!state.active) {
                    return;
                }

                if (state.textBuffer.length > 0) {
                    state.currentText += state.textBuffer;
                    state.textBuffer = '';
                }
                
                const text = state.currentText.trim(); 
                
                if (state.contentDiv) {
                    state.contentDiv.innerHTML = marked.parse(text);
                    
                    if (target.endsWith('_chat')) {
                        state.contentDiv.querySelectorAll('pre').forEach(pre => {
                            if (pre.querySelector('code')) {
                                const codeText = pre.textContent;
                                pre.outerHTML = renderCodeBlock(codeText);
                            }
                        });
                    }
                    
                    addCopyButtonsTo(state.contentDiv);
                    
                    if (target.endsWith('_thoughts') && state.summary) {
                         state.summary.textContent = 'View Thinking Process (Finished)';
                    }
                    
                    if (target.endsWith('_chat') && !isError && text.length > 0) {
                        const history = target === 'ai_chat' ? aiChatHistory : pdfChatHistory;
                        
                        const lastMsg = history[history.length - 1];
                        if (!lastMsg || lastMsg.sender !== 'ai' || lastMsg.text !== text) {
                            history.push({ sender: 'ai', text: text, imageB64: null });
                        }
                        autosaveChat();
                    }
                }
                
                cleanupStreaming(target);

                if (target.endsWith('_chat')) {
                    if (target === 'pdf_chat' && currentPDFName) {
                        setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                    } else {
                        setUIState('worker_ready', 'AI worker connected.');
                    }
                }
            } 
            
            function sendMessage(question, tab, imageB64 = null, isRetry = false) {
                if (!question && !imageB64) return;
                if (!socket || socket.readyState !== WebSocket.OPEN) return; 
                if (streamingState.pdf_chat.active || streamingState.ai_chat.active) return; 
                
                lastUserMessageText = question;
                lastUserMessageImageB64 = imageB64;
                
                const history = tab === 'ai_chat' ? aiChatHistory : pdfChatHistory;
                
                if (!isRetry) {
                    addMessage(question, 'user', tab, imageB64);
                }
                
                const historyForWorker = history.slice(0, -1);
                
                if (tab === 'pdf_chat') {
                    socket.send(JSON.stringify({ 
                        type: 'ask', 
                        target: 'pdf_chat',
                        data: { question: question, history: historyForWorker } 
                    })); 
                } else {
                    const payload = { 
                        question: question, 
                        history: historyForWorker, 
                        image_b64: imageB64 
                    }; 
                    const taskType = imageB64 ? 'general_chat_with_image' : 'general_chat'; 
                    
                    socket.send(JSON.stringify({ 
                        type: taskType, 
                        target: 'ai_chat',
                        data: payload 
                    })); 
                }
                
                ui.messageInput.value = ''; 
                ui.messageInputAI.value = '';
                ui.imagePreviewContainerAI.style.display = 'none';
                ui.imageUploadAI.value = '';
                uploadedImageB64 = null; 
                setUIState('ai_thinking', 'AI is thinking...'); 
            }
            
            // --- UI HOOKS ---
            ui.sendButton.addEventListener('click', () => sendMessage(ui.messageInput.value.trim(), 'pdf_chat'));
            ui.messageInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessage(ui.messageInput.value.trim(), 'pdf_chat'); 
                } 
            });
            ui.sendButtonAI.addEventListener('click', () => sendMessage(ui.messageInputAI.value.trim(), 'ai_chat', uploadedImageB64));
            ui.messageInputAI.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessage(ui.messageInputAI.value.trim(), 'ai_chat', uploadedImageB64); 
                } 
            });
            
            function toggleFastMode(button) {
                fastMode = !fastMode;
                [ui.fastModeButtonAi, ui.fastModeButtonPdf].forEach(btn => {
                    if (fastMode) {
                        btn.classList.add('fast-active');
                        btn.textContent = '‚ö° FAST MODE ACTIVE';
                    } else {
                        btn.classList.remove('fast-active');
                        btn.textContent = '‚ö° Fast Paste';
                    }
                });
                if (fastMode && Object.values(streamingState).some(s => s.active) && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = setInterval(() => renderCharacters(), 1); 
                } else if (!fastMode && Object.values(streamingState).some(s => s.active)) {
                    clearInterval(renderInterval);
                    renderInterval = setInterval(() => renderCharacters(), RENDER_SPEED);
                }
            }
            ui.fastModeButtonPdf.addEventListener('click', () => toggleFastMode(ui.fastModeButtonPdf));
            ui.fastModeButtonAi.addEventListener('click', () => toggleFastMode(ui.fastModeButtonAi));
            
            function renderHistory(history, target = 'pdf_chat') {
                const container = (target === 'ai_chat') ? ui.chatContainerAI : ui.chatContainer;
                container.innerHTML = '';
                history.forEach(msg => {
                    const bubble = document.createElement('div');
                    bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                    if (msg.sender === 'user') {
                        bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                        const textNode = document.createElement('div');
                        textNode.textContent = msg.text;
                        bubble.appendChild(textNode);
                        if (msg.imageB64) {
                            const img = document.createElement('img');
                            img.src = `data:image/jpeg;base64,${msg.imageB64}`;
                            bubble.appendChild(img);
                        }
                    } else {
                        bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                        const textNode = document.createElement('div');
                        let finalHtml = marked.parse(msg.text);
                        
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = finalHtml;
                        tempDiv.querySelectorAll('pre').forEach(pre => {
                            if (pre.querySelector('code')) {
                                const codeText = pre.textContent;
                                pre.outerHTML = renderCodeBlock(codeText);
                            }
                        });
                        finalHtml = tempDiv.innerHTML;
                        
                        textNode.innerHTML = finalHtml;
                        bubble.appendChild(textNode);
                        addCopyButtonsTo(bubble);
                    }
                    container.appendChild(bubble);
                });
                container.scrollTop = container.scrollHeight;
            }

            function autosaveChat() { 
                const token = sessionStorage.getItem('ai_toolkit_token');
                if (!token) return; // Only save chats for logged-in users

                const historyToSave = (activeTab === 'ai_chat') ? aiChatHistory : pdfChatHistory; 
                if (historyToSave.length === 0) return; 
                
                let chatId = (activeTab === 'ai_chat') ? 
                sessionStorage.getItem('currentAIChatId') : 
                sessionStorage.getItem('currentPdfChatId'); 
                const firstUserMessage = historyToSave.find(m => m.sender === 'user')?.text || 'New Chat'; 

                const chatName = (activeTab === 'pdf_chat' && 
                currentPDFName) ? `${currentPDFName.replace('.pdf', '')}` : 
                firstUserMessage.substring(0, 30); 
                
                if (!chatId) { 
                    chatId = `chat_${Date.now()}`; 
                    if (activeTab === 'ai_chat') sessionStorage.setItem('currentAIChatId', chatId); 
                    else sessionStorage.setItem('currentPdfChatId', chatId); 
                } 
                
                const payload = JSON.parse(atob(token.split('.')[1]));
                const username = payload.sub;
                const storageKey = `${username}_${chatId}`;
                
                const chatData = { 
                    id: chatId, name: chatName, type: activeTab, 
                    timestamp: new Date().toISOString(), history: historyToSave, 
                    pdfName: (activeTab === 'pdf_chat') ? currentPDFName : null 
                }; 
                
                localStorage.setItem(storageKey, JSON.stringify(chatData)); 
            } 
            
            function loadSavedChats() { 
                const token = sessionStorage.getItem('ai_toolkit_token');
                if (!token) {
                    ui.savedChatsList.innerHTML = '<p class="text-slate-400">Log in to save and view chats.</p>';
                    return;
                }
                const payload = JSON.parse(atob(token.split('.')[1]));
                const username = payload.sub;

                ui.sidebarTitle.textContent = activeTab === 'pdf_chat' ? "Saved PDF Chats" : "Saved AI Chats"; 
                ui.savedChatsList.innerHTML = ''; 
                const chats = []; 
                
                for (let i = 0; i < localStorage.length; i++) { 
                    const key = localStorage.key(i); 
                    if (key.startsWith(`${username}_chat_`)) { 
                        const chat = JSON.parse(localStorage.getItem(key)); 
                        if (chat.type === activeTab) chats.push(chat); 
                    } 
                } 
                
                chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); 
                
                if (chats.length === 0) { 
                    ui.savedChatsList.innerHTML = '<p class="text-slate-400">No saved chats.</p>'; 
                } else { 
                    chats.forEach(chat => { 
                        const item = document.createElement('div'); 
                        item.className = 'p-2 bg-slate-700 rounded-md cursor-pointer hover:bg-slate-600 truncate flex justify-between items-center'; 
                        item.textContent = chat.name; 
                        
                        const storageKey = `${username}_${chat.id}`;
                        item.onclick = () => loadChat(storageKey); 
                        
                        const deleteBtn = document.createElement('button'); 
                        deleteBtn.className = 'text-red-400 hover:text-red-300 ml-2'; 
                        deleteBtn.innerHTML = '&times;'; 
                        deleteBtn.onclick = (e) => { 
                            e.stopPropagation(); 
                            if (confirm(`Delete "${chat.name}"?`)) { 
                                localStorage.removeItem(storageKey); 
                                loadSavedChats(); 
                            } 
                        }; 
                        item.appendChild(deleteBtn); 
                        ui.savedChatsList.appendChild(item); 
                    }); 
                } 
            } 

            function loadChat(storageKey) { 
                const chatData = JSON.parse(localStorage.getItem(storageKey)); 
                if (!chatData) return; 
                
                if (chatData.type === 'pdf_chat') { 
                    pdfChatHistory = chatData.history; 
                    currentPDFName = chatData.pdfName; 
                    sessionStorage.setItem('currentPdfChatId', chatData.id); 
                    renderHistory(pdfChatHistory, 'pdf_chat'); 
                    ui.pdfTitle.textContent = currentPDFName || 'PDF Preview'; 
                    ui.pdfViewer.src = ''; 
                    setUIState('worker_ready', `Loaded chat for '${currentPDFName}'. Re-upload file to continue.`); 
                    addMessage(`Please re-upload "${currentPDFName}" to continue this conversation.`, 'system', 'pdf_chat'); 
                } else { 
                    aiChatHistory = chatData.history; 
                    sessionStorage.setItem('currentAIChatId', chatData.id); 
                    renderHistory(aiChatHistory, 'ai_chat'); 
                    setUIState('worker_ready', 'AI worker connected.'); 
                } 
                ui.sidebar.classList.add('-translate-x-full'); 
            } 

            function startNewChat() { 
                if (activeTab === 'pdf_chat') { 
                    pdfChatHistory = []; 
                    currentPDFName = null; 
                    sessionStorage.removeItem('currentPdfChatId'); 
                    ui.chatContainer.innerHTML = ''; 
                    ui.pdfTitle.textContent = 'PDF Preview'; 
                    ui.pdfViewer.src = ''; 
                } else { 
                    aiChatHistory = []; 
                    sessionStorage.removeItem('currentAIChatId'); 
                    ui.chatContainerAI.innerHTML = ''; 
                } 
                setUIState('worker_ready', 'AI worker connected.'); 
            } 

            async function uploadPDF() { 
                const file = ui.pdfUploadInput.files[0]; 
                if (!file) return; 
                
                startNewChat(); 
                currentPDFName = file.name; 
                ui.pdfTitle.textContent = currentPDFName; 
                ui.pdfViewer.src = URL.createObjectURL(file); 
                setUIState('processing', `Processing '${file.name}'...`); 
                addMessage(`Uploading and sending to worker...`, 'ai', 'pdf_chat'); 
                
                let user_id;
                const token = sessionStorage.getItem('ai_toolkit_token');
                if (token) {
                    const payload = JSON.parse(atob(token.split('.')[1]));
                    user_id = payload.sub;
                } else {
                    user_id = localStorage.getItem('ai_toolkit_user_id');
                }

                const formData = new FormData(); 
                formData.append('file', file); 
                
                try { 
                    const response = await fetch(`/upload/${user_id}`, { method: 'POST', body: formData }); 
                    if (!response.ok) { 
                        const errorData = await response.json(); 
                        throw new Error(errorData.detail || 'Failed to start PDF processing.'); 
                    } 
                } catch (error) { 
                    addMessage(`Error: ${error.message}`, 'ai', 'pdf_chat'); 
                    setUIState('worker_ready', 'Upload failed.'); 
                } 
            } 

            function handleImageFile(file) { 
                if (!file || !file.type.startsWith('image/')) return; 
                
                const reader = new FileReader(); 
                reader.onload = (event) => { 
                    uploadedImageB64 = event.target.result.split(',')[1]; 
                    ui.imagePreviewAI.src = event.target.result; 
                    ui.imagePreviewContainerAI.style.display = 'block'; 
                }; 
                reader.readAsDataURL(file); 
            } 
            
            // --- Event Listeners for UI ---
            ui.tabChatPDF.addEventListener('click', () => { 
                activeTab = 'pdf_chat'; 
                ui.viewChatPDF.style.display = 'grid'; 
                ui.viewAIChat.style.display = 'none'; 
                ui.tabChatPDF.classList.add('active'); 
                ui.tabAIChat.classList.remove('active'); 
            }); 
            
            ui.tabAIChat.addEventListener('click', () => { 
                activeTab = 'ai_chat'; 
                ui.viewChatPDF.style.display = 'none'; 
                ui.viewAIChat.style.display = 'flex'; 
                ui.tabChatPDF.classList.remove('active'); 
                ui.tabAIChat.classList.add('active'); 
            }); 
            
            ui.openSidebarButton.addEventListener('click', () => { 
                loadSavedChats(); 
                ui.sidebar.classList.remove('-translate-x-full'); 
            }); 
            
            ui.closeSidebarButton.addEventListener('click', () => 
                ui.sidebar.classList.add('-translate-x-full') 
            ); 
            
            ui.newChatButton.addEventListener('click', () => { 
                startNewChat(); 
                ui.sidebar.classList.add('-translate-x-full'); 
            }); 
            
            ui.pdfUploadInput.addEventListener('change', uploadPDF); 
            
            ui.imageUploadAI.addEventListener('change', (e) => handleImageFile(e.target.files[0])); 
            
            ui.removeImageButtonAI.addEventListener('click', () => { 
                uploadedImageB64 = null; 
                ui.imagePreviewContainerAI.style.display = 'none'; 
                ui.imageUploadAI.value = ''; 
            }); 
            
            ui.messageInputAI.addEventListener('paste', (e) => { 
                const items = (e.clipboardData || window.clipboardData).items; 
                for (const item of items) { 
                    if (item.kind === 'file' && item.type.startsWith('image/')) { 
                        e.preventDefault(); 
                        const file = item.getAsFile(); 
                        handleImageFile(file); 
                        return; 
                    } 
                } 
            }); 

            // Initialize 
            updateAuthUI();
            checkWorkerStatus(); 
            ui.tabChatPDF.click(); 
        }); 
    </script>
</body>
</html>
