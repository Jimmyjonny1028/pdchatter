<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Toolkit</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Base styles */
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 90%; word-wrap: break-word; white-space: pre-wrap; margin-bottom: 0.5rem; /* Consistent spacing */ }
        .user-bubble { background-color: #3b82f6; /* Brighter blue */ color: white; border-radius: 1rem 1rem 0.25rem 1rem; /* Rounded specific corners */ }
        .ai-bubble { background-color: #4b5563; /* Slightly lighter gray */ color: #e5e7eb; border-radius: 1rem 1rem 1rem 0.25rem; /* Rounded specific corners */ }

        /* --- STYLES FOR AUTH MODAL --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.8); /* Darker overlay */ display: flex; /* Use flex for centering */
            justify-content: center; align-items: center; z-index: 50;
        }
        .modal-content {
            background-color: #1f2937; /* Dark gray */ padding: 2rem; border-radius: 0.75rem; /* More rounded */
            width: 90%; max-width: 400px; color: #d1d5db; /* Light gray text */ box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .modal-content input { background-color: #374151; border: 1px solid #4b5563; color: white; padding: 0.5rem; /* Added padding */ border-radius: 0.375rem; /* Added rounding */ }
        .modal-content label { color: #9ca3af; margin-bottom: 0.25rem; display: block; /* Ensure label takes space */ }

        /* --- STYLES FOR THOUGHTS BUBBLE --- */
        .thoughts-bubble {
            background-color: #1f2937; /* Match modal */ color: #9ca3af; font-size: 0.9rem;
            border-left: 3px solid #6366f1; padding: 0.5rem 1rem; margin: 0.5rem 0; border-radius: 0 0.5rem 0.5rem 0; /* Slight rounding */
        }
        .thoughts-bubble details > summary {
            list-style: none; padding: 0.25rem 0; cursor: pointer; /* Removed padding */
            outline: none; color: #a5b4fc; font-weight: 500; /* Adjusted weight */
        }
        .thoughts-bubble details[open] > summary {
            border-bottom: 1px solid #374151; margin-bottom: 0.75rem; padding-bottom: 0.25rem;
        }
        .thoughts-content pre {
            background-color: #111827; /* Darker pre background */ padding: 0.75rem; border-radius: 0.375rem;
            white-space: pre-wrap; overflow-x: auto; font-size: 0.85em; /* Slightly smaller */
        }

        /* --- STYLES FOR SPEED BUTTON --- */
        .speed-button {
            background-color: #4f46e5; /* Adjusted base color */ color: white; padding: 0.5rem; border-radius: 0.5rem;
            cursor: pointer; transition: background-color 0.2s, opacity 0.2s;
            opacity: 0.9; /* Slightly less transparent */ font-weight: 600; white-space: nowrap;
        }
        .speed-button:hover { opacity: 1; background-color: #6366f1; } /* Lighter hover */
        .speed-button.fast-active { background-color: #f59e0b; opacity: 1; }

        /* --- STYLES FOR CODE BLOCK WITH LINE NUMBERS --- */
        .code-block-container {
            position: relative; background-color: #111827; /* Darker bg */ border-radius: 0.5rem;
            margin: 1rem 0; padding: 0; overflow: hidden; border: 1px solid #374151; /* Subtle border */
        }
        .code-block-container .language-tag {
            position: absolute; top: 0; left: 0; background-color: #374151; color: #9ca3af; /* Muted tag */
            padding: 0.1rem 0.5rem; font-size: 0.7rem; border-top-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem; z-index: 10;
        }
        .code-block-container ol { list-style-type: none; padding: 0; margin: 0; display: flex; font-size: 0.875rem; /* Adjusted font size */ }
        .line-numbers {
            background-color: #1f2937; /* Match modal bg */ color: #6b7280; text-align: right;
            padding: 0.75rem 0.5rem; user-select: none; line-height: 1.6; /* Increased line height */ border-right: 1px solid #374151;
        }
        .code-content { flex-grow: 1; padding: 0.75rem 1rem; overflow-x: auto; }
        .code-content code {
            display: block; white-space: pre; color: #d1d5db; line-height: 1.6; /* Match line numbers */
            font-family: 'Fira Code', 'Courier New', Courier, monospace; /* Changed font */
        }

        /* --- STYLES FOR RETRY BUTTON --- */
        .retry-button {
            background-color: #ef4444; /* Brighter red */ color: white; padding: 0.5rem 1rem; border-radius: 0.375rem;
            cursor: pointer; font-weight: 600; margin-top: 0.5rem; transition: background-color 0.2s;
        }
        .retry-button:hover { background-color: #dc2626; }

        #error-retry-container-pdf,
        #error-retry-container-ai { display: none; justify-content: center; padding: 0 1rem 0.5rem 1rem; } /* Adjusted padding */

        /* --- UI Element Styling --- */
        #chat-sidebar { transition: transform 0.3s ease-in-out; border-right: 1px solid #1f2937; } /* Add border */
        .tab-button { border-bottom-width: 2px; border-color: transparent; transition: color 0.2s, border-color 0.2s; }
        .tab-button.active { border-color: #6366f1; color: #818cf8; } /* Lighter active color */

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; border-radius: 4px;}
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; border: 2px solid #1f2937; } /* Add border */
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* AI Bubble Content Styling */
        .ai-bubble pre { background-color: #111827; border: 1px solid #374151; color: #d1d5db; padding: 0.75rem 1rem; border-radius: 0.5rem; overflow-x: auto; position: relative; font-size: 0.875rem; }
        .ai-bubble code { font-family: 'Fira Code', 'Courier New', Courier, monospace; }
        .user-bubble img { max-width: 150px; border-radius: 0.5rem; margin-top: 0.5rem; border: 1px solid rgba(255,255,255,0.1); } /* Add border to images */

        /* Copy Button Styling */
        .copy-button { position: absolute; top: 0.5rem; right: 0.5rem; background-color: #374151; color: #9ca3af; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem; opacity: 0; transition: opacity 0.2s, background-color 0.2s; z-index: 10;}
        pre:hover .copy-button, .code-block-container:hover .copy-button { opacity: 1; }
        .copy-button:hover { background-color: #4b5563; color: #e5e7eb; }

        /* Table Styling */
        .ai-bubble table { width: 100%; margin: 1em 0; border-collapse: collapse; border: 1px solid #4b5563; border-radius: 0.5rem; overflow: hidden; /* Ensure border radius applies */ }
        .ai-bubble th, .ai-bubble td { border: 1px solid #4b5563; padding: 0.6rem 0.8rem; text-align: left; }
        .ai-bubble th { background-color: #1f2937; font-weight: 600; /* Semibold */ }
        .ai-bubble tr:nth-child(even) { background-color: rgba(55, 65, 81, 0.5); } /* Subtle striping */

        /* --- STYLES FOR THINKING BUBBLE --- */
        .thinking-bubble {
            background-color: #4b5563; color: #cbd5e1; display: inline-flex; /* Use inline-flex */ align-items: center;
            padding: 0.6rem 1rem; border-radius: 1rem 1rem 1rem 0.25rem; /* Match AI bubble */ align-self: flex-start;
            margin-right: auto; margin: 0.5rem 0; /* Consistent margin */
        }
        .thinking-bubble span { margin-right: 0.5rem; } /* Space before dots */
        .dot-flashing {
            position: relative; width: 6px; height: 6px; /* Smaller dots */ border-radius: 50%;
            background-color: #9ca3af; color: #9ca3af; /* Muted color */
            animation: dotFlashing 1s infinite linear alternate; animation-delay: .5s; margin: 0 3px; /* Adjust spacing */
        }
        .dot-flashing::before, .dot-flashing::after {
            content: ''; display: inline-block; position: absolute; top: 0;
            width: 6px; height: 6px; border-radius: 50%;
            background-color: #9ca3af; color: #9ca3af;
        }
        .dot-flashing::before { left: -12px; animation: dotFlashing 1s infinite alternate; animation-delay: 0s; } /* Adjust spacing */
        .dot-flashing::after { left: 12px; animation: dotFlashing 1s infinite alternate; animation-delay: 1s; } /* Adjust spacing */

        @keyframes dotFlashing {
            0% { background-color: #9ca3af; }
            50%, 100% { background-color: rgba(156, 163, 175, 0.3); }
        }
        /* --- Sidebar delete button style --- */
        .delete-chat-btn { margin-left: auto; padding: 0 0.5rem; color: #f87171; background: none; border: none; font-size: 1.25rem; line-height: 1; cursor: pointer; opacity: 0.7; transition: opacity 0.2s, color 0.2s;}
        .delete-chat-btn:hover { color: #ef4444; opacity: 1; } /* Brighter red */
        /* Sidebar item style */
        .sidebar-chat-item { transition: background-color 0.2s; }

    </style>
</head>
<body class="bg-slate-900 h-screen overflow-hidden text-slate-200"> <!-- Dark theme body -->

    <!-- Authentication Modal -->
    <div id="auth-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="auth-title" class="text-2xl font-bold mb-4 text-white">Login</h2>
            <div id="auth-error" class="text-red-400 mb-2" style="display: none;"></div>
            <form id="auth-form">
                <div class="mb-4">
                    <label for="username" class="block mb-1 text-slate-300">Username</label>
                    <input type="text" id="username" class="w-full bg-slate-700 border border-slate-600 rounded p-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent" required>
                </div>
                <div class="mb-6">
                    <label for="password" class="block mb-1 text-slate-300">Password</label>
                    <input type="password" id="password" class="w-full bg-slate-700 border border-slate-600 rounded p-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent" required>
                </div>
                <div class="flex justify-between items-center">
                    <div>
                        <button type="submit" id="auth-submit-button" class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded text-white font-semibold transition duration-200 disabled:opacity-50" disabled>Login</button> <!-- Start disabled -->
                        <button type="button" id="auth-close-button" class="text-slate-400 hover:text-white ml-2">Cancel</button>
                    </div>
                    <button type="button" id="auth-switch-button" class="text-sm text-indigo-400 hover:underline">Need an account? Sign up</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Main Flex Container -->
    <div class="flex h-full">

        <!-- Sidebar -->
        <aside id="chat-sidebar" class="w-64 bg-slate-800 text-slate-100 flex flex-col p-4 transform -translate-x-full fixed h-full z-20 shadow-lg border-r border-slate-700">
            <div class="flex justify-between items-center mb-4 border-b border-slate-600 pb-2">
                <h2 id="sidebar-title" class="text-xl font-semibold">Saved Chats</h2>
                <button id="close-sidebar-button" class="text-slate-400 hover:text-white text-2xl leading-none p-1 rounded hover:bg-slate-700">&times;</button>
            </div>
            <div id="user-status" class="text-center text-sm text-slate-400 mb-2">Guest Mode</div>
            <button id="new-chat-button" class="w-full text-left p-2 mb-2 bg-indigo-600 rounded hover:bg-indigo-700 text-white font-semibold transition duration-200">Ôºã New Chat</button>
            <div id="saved-chats-list" class="flex-1 overflow-y-auto space-y-1 pr-1"></div>
        </aside>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col h-full bg-slate-900">
            <!-- Header -->
            <header class="bg-slate-800 shadow-md p-4 flex items-center justify-between z-10 border-b border-slate-700">
                <div class="flex items-center space-x-4">
                    <button id="open-sidebar-button" class="p-2 rounded-md text-slate-300 hover:bg-slate-700 hover:text-white transition duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                    </button>
                    <div>
                        <h1 class="text-2xl font-bold text-slate-100">AI Toolkit</h1>
                        <p id="status" class="text-sm text-slate-400">Status: Connecting to server...</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="tab-chatpdf" class="tab-button py-2 px-3 text-slate-400 font-semibold border-b-2 hover:text-indigo-400 transition duration-200">ChatPDF</button>
                    <button id="tab-ai-chat" class="tab-button py-2 px-3 text-slate-400 font-semibold border-b-2 hover:text-indigo-400 transition duration-200">AI Chat</button>
                    <button id="login-button" class="bg-indigo-600 text-white px-4 py-1.5 rounded-md hover:bg-indigo-700 font-semibold transition duration-200">Login / Sign Up</button>
                    <button id="logout-button" class="bg-red-600 text-white px-4 py-1.5 rounded-md hover:bg-red-700 font-semibold transition duration-200" style="display: none;">Logout</button>
                </div>
            </header>

            <!-- ChatPDF View -->
            <div id="view-chatpdf" class="flex-1 grid md:grid-cols-2 gap-4 p-4 overflow-hidden">
                <!-- PDF Viewer Section -->
                <section class="bg-slate-700 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-600">
                    <div class="p-2 border-b border-slate-600 bg-slate-800"><h2 id="pdf-title" class="text-lg font-semibold text-slate-200 truncate">PDF Preview</h2></div>
                    <div class="flex-1 p-2 bg-slate-600"><embed id="pdf-viewer" src="" type="application/pdf" width="100%" height="100%"/></div>
                </section>
                <!-- ChatPDF Chat Section -->
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-700">
                    <main id="chat-container" class="flex-1 p-4 space-y-2 overflow-y-auto"></main>
                    <div id="error-retry-container-pdf" class="bg-slate-800 px-4 pb-2"></div>
                    <footer class="bg-slate-900/80 p-3 border-t border-slate-700"> <!-- Reduced padding -->
                        <div class="flex items-center space-x-2">
                            <label for="pdf-upload" id="upload-label" class="cursor-not-allowed bg-slate-500 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-200 opacity-50">üìÅ Upload</label>
                            <input id="pdf-upload" type="file" class="hidden" accept=".pdf" disabled>
                            <button id="fast-mode-button-pdf" class="speed-button text-sm px-3 py-2">‚ö° Fast Paste</button>
                            <input type="text" id="message-input" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-transparent" placeholder="Connecting..." disabled>
                            <button id="send-button" class="bg-slate-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>

            <!-- AI Chat View -->
            <div id="view-ai-chat" style="display: none;" class="flex-1 flex flex-col p-4 overflow-hidden">
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden border border-slate-700">
                    <main id="chat-container-ai" class="flex-1 p-4 space-y-2 overflow-y-auto"></main>
                    <!-- Image Preview Area -->
                    <div id="image-preview-container-ai" class="p-3 border-t border-slate-700 bg-slate-900/50" style="display: none;"> <!-- Reduced padding -->
                        <div class="relative w-20 h-20"> <!-- Smaller preview -->
                            <img id="image-preview-ai" class="w-full h-full object-cover rounded-md border border-slate-600">
                            <button id="remove-image-button-ai" class="absolute top-0 right-0 bg-red-600 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs -mt-2 -mr-2 leading-none hover:bg-red-700">&times;</button>
                        </div>
                    </div>
                     <div id="error-retry-container-ai" class="bg-slate-800 px-4 pb-2"></div>
                    <!-- Footer Input Area -->
                    <footer class="bg-slate-900/80 p-3 border-t border-slate-700"> <!-- Reduced padding -->
                        <div class="flex items-center space-x-2">
                            <label for="image-upload-ai" class="cursor-pointer text-slate-400 hover:text-indigo-400 p-2 rounded hover:bg-slate-700 transition duration-200">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                            </label>
                            <input id="image-upload-ai" type="file" class="hidden" accept="image/jpeg,image/png">
                            <button id="fast-mode-button-ai" class="speed-button text-sm px-3 py-2">‚ö° Fast Paste</button>
                            <input type="text" id="message-input-ai" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-transparent" placeholder="Connecting..." disabled>
                            <button id="send-button-ai" class="bg-slate-500 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Element References ---
            const ui = {
                status: document.getElementById('status'),
                sidebar: document.getElementById('chat-sidebar'),
                sidebarTitle: document.getElementById('sidebar-title'),
                openSidebarButton: document.getElementById('open-sidebar-button'),
                closeSidebarButton: document.getElementById('close-sidebar-button'),
                newChatButton: document.getElementById('new-chat-button'),
                savedChatsList: document.getElementById('saved-chats-list'),
                userStatus: document.getElementById('user-status'),

                tabChatPDF: document.getElementById('tab-chatpdf'),
                tabAIChat: document.getElementById('tab-ai-chat'),
                viewChatPDF: document.getElementById('view-chatpdf'),
                viewAIChat: document.getElementById('view-ai-chat'),

                chatContainer: document.getElementById('chat-container'),
                messageInput: document.getElementById('message-input'),
                sendButton: document.getElementById('send-button'),
                pdfUploadInput: document.getElementById('pdf-upload'),
                uploadLabel: document.getElementById('upload-label'),
                pdfViewer: document.getElementById('pdf-viewer'),
                pdfTitle: document.getElementById('pdf-title'),
                fastModeButtonPdf: document.getElementById('fast-mode-button-pdf'),
                errorRetryContainerPdf: document.getElementById('error-retry-container-pdf'),

                chatContainerAI: document.getElementById('chat-container-ai'),
                messageInputAI: document.getElementById('message-input-ai'),
                sendButtonAI: document.getElementById('send-button-ai'),
                imageUploadAI: document.getElementById('image-upload-ai'),
                imagePreviewContainerAI: document.getElementById('image-preview-container-ai'),
                imagePreviewAI: document.getElementById('image-preview-ai'),
                removeImageButtonAI: document.getElementById('remove-image-button-ai'),
                fastModeButtonAi: document.getElementById('fast-mode-button-ai'),
                errorRetryContainerAi: document.getElementById('error-retry-container-ai'),

                authModal: document.getElementById('auth-modal'),
                authTitle: document.getElementById('auth-title'),
                authError: document.getElementById('auth-error'),
                authForm: document.getElementById('auth-form'),
                authSubmitButton: document.getElementById('auth-submit-button'),
                authCloseButton: document.getElementById('auth-close-button'),
                authSwitchButton: document.getElementById('auth-switch-button'),
                loginButton: document.getElementById('login-button'),
                logoutButton: document.getElementById('logout-button'),
                usernameInput: document.getElementById('username'),
                passwordInput: document.getElementById('password')
            };

            // --- State Variables ---
            let pdfChatHistory = [];
            let aiChatHistory = [];
            let currentPDFName = null;
            let activeTab = 'pdf_chat'; // Default tab
            let uploadedImageB64 = null;
            let fastMode = false;
            let lastUserMessageText = null;
            let lastUserMessageImageB64 = null;
            let isLoginMode = true; // For auth modal
            let socket, statusInterval, pingInterval;
            let thinkingBubbleElement = null;
            let guestId; // <-- *** FIX: Declare guestId here ***

            // *** FIX: Initialize guestId inside DOMContentLoaded with error handling ***
            try {
                guestId = localStorage.getItem('ai_toolkit_user_id');
                if (!guestId) {
                    guestId = `guest_${Math.random().toString(36).substr(2, 9)}`;
                    localStorage.setItem('ai_toolkit_user_id', guestId);
                }
            } catch (e) {
                console.warn("localStorage is not available. Using temporary guest ID.", e.message);
                guestId = `guest_${Math.random().toString(36).substr(2, 9)}`;
            }
            // *** END FIX ***


            const RENDER_API_BASE_URL = "https://chatpdf-server-shtq.onrender.com"; // Your backend URL

            // State for managing streaming responses
            let streamingState = {
                pdf_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                ai_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                pdf_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' },
                ai_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' }
            };

            let renderInterval = null;
            const RENDER_SPEED = 10; // Milliseconds between rendering characters
            const CHARS_PER_TICK = 3; // Characters to render each interval

            // --- Helper Functions ---

            // Function to add a message bubble to the UI
            function addMessage(text, sender, target = activeTab, imageB64 = null) {
                 const history = target.startsWith('ai_') ? aiChatHistory : pdfChatHistory;
                 const container = target.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;

                 if (target.endsWith('_thoughts')) {
                    const bubble = document.createElement('div');
                    bubble.classList.add('thoughts-bubble', 'w-full', 'self-start', 'mr-auto');
                    const details = document.createElement('details'); details.classList.add('w-full');
                    const summary = document.createElement('summary'); summary.textContent = '...AI is thinking... (Click to view)';
                    const contentDiv = document.createElement('div'); contentDiv.classList.add('thoughts-content', 'pt-2', 'pb-1');
                    details.appendChild(summary); details.appendChild(contentDiv); bubble.appendChild(details);
                    container.appendChild(bubble); container.scrollTop = container.scrollHeight;
                    return { bubble: bubble, contentDiv: contentDiv, summary: summary };
                 }

                 if (sender === 'system') {
                    const bubble = document.createElement('div');
                    bubble.classList.add('text-center', 'text-xs', 'text-slate-400', 'my-2', 'px-4');
                    bubble.textContent = text;
                    container.appendChild(bubble); container.scrollTop = container.scrollHeight;
                    return { bubble: bubble, contentDiv: bubble, summary: null };
                 }

                 const bubble = document.createElement('div');
                 bubble.classList.add('chat-bubble', 'p-3', 'w-fit', 'my-1');

                 if (sender === 'user') {
                     bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                 } else {
                     bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                 }

                 const textNode = document.createElement('div');
                 textNode.textContent = text || ''; // Ensure text content even if empty
                 bubble.appendChild(textNode);

                 if (sender === 'user' && imageB64) {
                     const img = document.createElement('img'); img.src = `data:image/jpeg;base64,${imageB64}`;
                     img.className = 'mt-2 rounded max-w-xs';
                     bubble.appendChild(img);
                 }

                 container.appendChild(bubble);
                 // Scroll to bottom using requestAnimationFrame for better timing
                 requestAnimationFrame(() => {
                     if (container) container.scrollTop = container.scrollHeight;
                 });


                 // Only add user messages to the history array here. AI messages added in finalizeStream.
                 if (sender === 'user') {
                     history.push({ sender, text: text || '', imageB64: imageB64 }); // Ensure text is string
                 }

                 return { bubble: bubble, contentDiv: textNode, summary: null };
            }

            // Helper for making authenticated API calls
            async function fetchWithAuth(url, options = {}) {
                const token = localStorage.getItem('ai_toolkit_token');
                const headers = { ...options.headers, 'Content-Type': 'application/json', };
                if (token) { headers['Authorization'] = `Bearer ${token}`; }

                try {
                    const response = await fetch(url, { ...options, headers });
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                        console.error("API Error:", response.status, errorData);
                        addMessage(`API Error: ${errorData.detail || response.statusText}`, 'system', activeTab);
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }
                    if (response.status === 204) { return null; }
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        return await response.json();
                    } else {
                        console.warn("Received non-JSON response from API:", await response.text());
                        if (url.includes('/chats') && options.method !== 'DELETE') {
                            throw new Error("Received non-JSON response when expecting chat data.");
                        }
                        return null; // For DELETE 204 or other non-JSON success
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                    addMessage(`Network or Server Error: ${error.message}`, 'system', activeTab);
                    throw error;
                }
            }

            // --- Authentication Logic ---
            function showAuthModal(show) {
                ui.authModal.style.display = show ? 'flex' : 'none';
                if (!show) { ui.authError.style.display = 'none'; ui.authForm.reset(); ui.authSubmitButton.disabled = true;} // Reset disabled state
                 else {
                     // Enable button only when both fields have content
                    ui.authSubmitButton.disabled = !(ui.usernameInput.value.trim() && ui.passwordInput.value.trim());
                 }
            }

            function updateAuthUI() {
                const token = localStorage.getItem('ai_toolkit_token');
                if (token) {
                    try {
                        const payload = JSON.parse(atob(token.split('.')[1]));
                        ui.userStatus.textContent = `Logged in: ${payload.sub}`;
                        ui.loginButton.style.display = 'none'; ui.logoutButton.style.display = 'block';
                    } catch (e) { handleLogout(); } // Log out if token is invalid
                } else {
                    ui.userStatus.textContent = 'Guest Mode';
                    ui.loginButton.style.display = 'block'; ui.logoutButton.style.display = 'none';
                }
            }

            async function handleAuthSubmit(event) {
                event.preventDefault();
                const username = ui.usernameInput.value.trim(); const password = ui.passwordInput.value.trim();
                 if (!username || !password) return; // Should be prevented by disabled button, but double-check

                const endpoint = isLoginMode ? `${RENDER_API_BASE_URL}/login` : `${RENDER_API_BASE_URL}/signup`;
                ui.authSubmitButton.disabled = true; // Prevent double submission
                ui.authSubmitButton.textContent = isLoginMode ? 'Logging in...' : 'Signing up...'; // Indicate processing
                ui.authError.textContent = ''; ui.authError.style.display = 'none';

                try {
                    const response = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username, password }) });
                    let data;
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        data = await response.json();
                    } else {
                         const textResponse = await response.text(); // Get text for better error
                         console.error("Non-JSON Auth Response:", textResponse);
                         throw new Error(`Server returned status ${response.status}. Check server logs.`);
                    }

                    if (!response.ok) { throw new Error(data.detail || 'An error occurred.'); }

                    if (isLoginMode) {
                        localStorage.setItem('ai_toolkit_token', data.access_token);
                        showAuthModal(false); updateAuthUI(); startNewChat();
                    } else {
                        isLoginMode = true; ui.authTitle.textContent = 'Login'; ui.authSubmitButton.textContent = 'Login';
                        ui.authSwitchButton.textContent = 'Need an account? Sign up'; ui.authError.style.display = 'block';
                        ui.authError.textContent = 'Signup successful! Please log in.'; ui.authForm.reset();
                    }
                } catch (error) {
                    ui.authError.style.display = 'block'; ui.authError.textContent = error.message;
                } finally {
                     // Reset button text and re-evaluate disabled state
                     ui.authSubmitButton.textContent = isLoginMode ? 'Login' : 'Sign Up';
                     ui.authSubmitButton.disabled = !(ui.usernameInput.value.trim() && ui.passwordInput.value.trim());
                }
            }

            function handleLogout() {
                localStorage.removeItem('ai_toolkit_token');
                sessionStorage.removeItem('currentAIChatId'); sessionStorage.removeItem('currentPdfChatId');
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.close(1000, "User logged out"); // Close WS with code 1000
                }
                updateAuthUI();
                startNewChat(); // Clear local state and trigger reconnection attempt
            }

            // --- WebSocket Connection ---
            async function checkWorkerStatus() {
                 try {
                    const response = await fetch(`${RENDER_API_BASE_URL}/status`);
                    if (!response.ok) throw new Error("Server not reachable");
                    const data = await response.json();
                    if (data.worker_connected) {
                        if (!socket || socket.readyState === WebSocket.CLOSED) {
                            setUIState('worker_ready', 'AI worker connected. Authenticating...');
                             if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }
                            connectWebSocket();
                        } else if (socket.readyState === WebSocket.OPEN){
                             setUIState('worker_ready', 'AI worker connected.'); // Already good
                             if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }
                        }
                        // If connecting, let the onopen/onmessage handle the final state
                    } else {
                        setUIState('waiting_for_worker', 'Waiting for local AI worker...');
                        if (!statusInterval && (!socket || socket.readyState === WebSocket.CLOSED)) { // Start polling only if not already polling or connected/connecting
                           statusInterval = setInterval(checkWorkerStatus, 5000);
                        }
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                    setUIState('error', 'Could not connect to server.');
                    if (!statusInterval && (!socket || socket.readyState === WebSocket.CLOSED)) { // Start polling on error too
                           statusInterval = setInterval(checkWorkerStatus, 5000);
                    }
                }
            }

            function connectWebSocket() {
                // Ensure no residual interval is running
                if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }

                const wsUrl = `${RENDER_API_BASE_URL.replace('http://', 'wss://').replace('https://', 'wss://')}/ws/web`;
                console.log("Attempting WebSocket connection to:", wsUrl);
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log("WebSocket connected. Sending auth...");
                    const token = localStorage.getItem('ai_toolkit_token');
                    // 'guestId' is now guaranteed to be set from the logic at the start of DOMContentLoaded
                    socket.send(JSON.stringify(token ? { type: 'auth', token: token } : { type: 'auth', user_id: guestId }));

                    if (pingInterval) clearInterval(pingInterval);
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify({ type: 'ping' })); }
                         else { clearInterval(pingInterval); pingInterval = null; }
                    }, 20000); // Send ping every 20 seconds
                };

                socket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        console.log("WS Message Received:", message); // Debugging
                        if (message.type === 'auth_success') {
                            console.log("Authentication successful!");
                             if (currentPDFName && activeTab === 'pdf_chat') { setUIState('ready_to_chat', `Ready: ${currentPDFName}`); }
                             else { setUIState('worker_ready', 'AI worker connected.'); }
                             // Load chats for logged-in user *after* auth success
                             if (localStorage.getItem('ai_toolkit_token')) { loadSavedChats(); }
                             return;
                        }
                        handleServerMessage(message);
                    } catch (error) { console.error("‚ùå Failed to handle message:", error, event.data); }
                };

                socket.onclose = (event) => {
                     console.log("WebSocket closed:", event.code, event.reason); // Debugging
                    clearInterval(pingInterval); pingInterval = null;
                    const wasConnected = ui.status.textContent.includes('connected') || ui.status.textContent.includes('Ready:');
                    const wasStreaming = Object.values(streamingState).some(s=>s?.active) || thinkingBubbleElement;
                    const targetTab = activeTab;
                    const intentionalClose = event.code === 1000; // Normal closure (e.g., logout)

                    cleanupStreaming();
                    socket = null; // Important: nullify socket object

                    if (!intentionalClose && wasConnected) {
                         setUIState('disconnected', 'Disconnected. Trying to reconnect...');
                         if (!statusInterval) { // Start polling only if not already polling
                              statusInterval = setInterval(checkWorkerStatus, 3000);
                         }
                    } else if (!intentionalClose) {
                        // It was never properly connected or disconnected unexpectedly before connecting fully
                        setUIState('error', 'Connection failed. Retrying...');
                        if (!statusInterval) {
                             statusInterval = setInterval(checkWorkerStatus, 3000);
                        }
                    }
                     else {
                         setUIState('disconnected', 'Disconnected.'); // Stay disconnected after logout
                    }

                    if (wasStreaming && !intentionalClose && lastUserMessageText) {
                        showRetryButton(targetTab, `Connection lost (Code ${event.code}). Please retry.`);
                    }
                };

                socket.onerror = (error) => { console.error("‚ùå WebSocket Error:", error); /* onclose handles UI and reconnection attempts */ };
            }


            // --- UI State & Display ---
            function setUIState(state, message = "") {
                ui.status.textContent = `Status: ${message}`;
                const isChatReady = state === 'ready_to_chat';
                const isWorkerReady = state === 'worker_ready' || isChatReady;
                const isProcessing = state === 'processing' || state === 'ai_thinking';
                const isConnected = state === 'worker_ready' || state === 'ready_to_chat' || state === 'ai_thinking'; // Considered connected if thinking

                // PDF Upload Button
                ui.pdfUploadInput.disabled = !isWorkerReady || isProcessing;
                ui.uploadLabel.classList.toggle('cursor-not-allowed', !isWorkerReady || isProcessing);
                ui.uploadLabel.classList.toggle('cursor-pointer', isWorkerReady && !isProcessing);
                ui.uploadLabel.classList.toggle('bg-slate-500', !isWorkerReady || isProcessing);
                ui.uploadLabel.classList.toggle('opacity-50', !isWorkerReady || isProcessing);
                ui.uploadLabel.classList.toggle('bg-blue-600', isWorkerReady && !isProcessing);
                ui.uploadLabel.classList.toggle('hover:bg-blue-700', isWorkerReady && !isProcessing);

                // Streaming State Check
                const isPdfStreaming = streamingState.pdf_chat.active || streamingState.pdf_thoughts.active || (thinkingBubbleElement && activeTab === 'pdf_chat');
                const isAiStreaming = streamingState.ai_chat.active || streamingState.ai_thoughts.active || (thinkingBubbleElement && activeTab === 'ai_chat');

                // PDF Chat Input
                const canUsePdfChat = isChatReady && !isPdfStreaming;
                ui.messageInput.disabled = !canUsePdfChat;
                ui.sendButton.disabled = !canUsePdfChat;
                ui.sendButton.classList.toggle('bg-slate-500', !canUsePdfChat);
                ui.sendButton.classList.toggle('opacity-50', !canUsePdfChat);
                ui.sendButton.classList.toggle('bg-indigo-600', canUsePdfChat);
                ui.sendButton.classList.toggle('hover:bg-indigo-700', canUsePdfChat);
                ui.messageInput.placeholder = canUsePdfChat ? "Ask a question about the PDF..." :
                                               isPdfStreaming ? "AI is processing..." :
                                               !isConnected ? "Connecting..." : // Changed from !isWorkerReady
                                               state === 'processing' ? `Processing '${currentPDFName}'...` :
                                               "Upload a PDF to begin...";

                // AI Chat Input
                const canUseAiChat = isWorkerReady && !isAiStreaming && state !== 'processing';
                ui.messageInputAI.disabled = !canUseAiChat;
                ui.sendButtonAI.disabled = !canUseAiChat;
                ui.sendButtonAI.classList.toggle('bg-slate-500', !canUseAiChat);
                ui.sendButtonAI.classList.toggle('opacity-50', !canUseAiChat);
                ui.sendButtonAI.classList.toggle('bg-indigo-600', canUseAiChat);
                ui.sendButtonAI.classList.toggle('hover:bg-indigo-700', canUseAiChat);
                 ui.messageInputAI.placeholder = canUseAiChat ? "Send a message, or paste an image..." :
                                                isAiStreaming ? "AI is processing..." :
                                                state === 'processing' ? "Processing PDF..." :
                                                "Connecting...";
            }

            function showThinkingBubble(tab) {
                removeThinkingBubble();
                const container = tab === 'ai_chat' ? ui.chatContainerAI : ui.chatContainer;
                thinkingBubbleElement = document.createElement('div');
                thinkingBubbleElement.classList.add('thinking-bubble');
                thinkingBubbleElement.innerHTML = `<span>AI is thinking</span> <div class="dot-flashing"></div>`;
                container.appendChild(thinkingBubbleElement); container.scrollTop = container.scrollHeight;
                setUIState('ai_thinking', 'AI is processing...'); // Update state
            }
             function removeThinkingBubble() {
                 if (thinkingBubbleElement) { thinkingBubbleElement.remove(); thinkingBubbleElement = null; }
                 // Don't reset UI state here, let finalizeStream or error/status handle it
            }


            // --- Message Sending / Receiving / Rendering ---
            function sendMessage(question, tab, imageB64 = null, isRetry = false) {
                 const trimmedQuestion = question.trim(); // Trim the question first
                 if (!trimmedQuestion && !imageB64) return; // Prevent empty/whitespace-only messages

                 if (!socket || socket.readyState !== WebSocket.OPEN) { addMessage("Error: Not connected.", 'system', tab); return; }
                 if (Object.values(streamingState).some(s=>s?.active) || thinkingBubbleElement) { console.warn("Processing..."); return; }

                 lastUserMessageText = trimmedQuestion; // Store trimmed version
                 lastUserMessageImageB64 = imageB64;
                 const history = tab === 'ai_chat' ? aiChatHistory : pdfChatHistory;

                 if (!isRetry) { addMessage(trimmedQuestion, 'user', tab, imageB64); } // Add trimmed message
                 showThinkingBubble(tab);

                 const historyForWorker = history.map(msg => ({ sender: msg.sender, text: msg.text }))
                                              .slice(0, isRetry ? undefined : -1); // Exclude current user message unless retry

                 let payloadData = { question: trimmedQuestion, history: historyForWorker }; // Send trimmed question
                 let taskType = tab === 'pdf_chat' ? 'ask' : (imageB64 ? 'general_chat_with_image' : 'general_chat');
                 if (imageB64 && tab === 'ai_chat') { payloadData.image_b64 = imageB64; }

                 socket.send(JSON.stringify({ type: taskType, target: tab, data: payloadData }));

                 ui.messageInput.value = ''; ui.messageInputAI.value = ''; // Clear inputs
                 ui.imagePreviewContainerAI.style.display = 'none'; ui.imageUploadAI.value = ''; uploadedImageB64 = null;
            }

            // --- Updated handleServerMessage ---
            function handleServerMessage(message) {
                 const targetKey = message.target || activeTab; // Use message target, fallback to activeTab
                 const isThought = targetKey.endsWith('_thoughts');
                 const mainTarget = isThought ? targetKey.replace('_thoughts', '_chat') : targetKey;

                switch (message.type) {
                    case 'status':
                        console.log("Received Status:", message.data); // <-- ADDED LOG
                        removeThinkingBubble(); // Remove thinking bubble on any status update
                        addMessage(message.data, 'system', mainTarget); // Add status as system message
                        // Specifically check for the "Ready for questions" message
                        if (message.data.includes("Ready for questions") && activeTab === 'pdf_chat') {
                             console.log("Setting UI state to ready_to_chat based on status message"); // <-- ADDED LOG
                             setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                        }
                        // Avoid resetting to 'worker_ready' if we just set it to 'ready_to_chat'
                        else if (!message.data.includes("Processing") && !(message.data.includes("Ready for questions") && activeTab === 'pdf_chat')) {
                             // Only reset if it's not a processing or the specific "Ready" message
                             if (socket && socket.readyState === WebSocket.OPEN) {
                                 // Check current state to avoid unnecessary updates
                                 const currentState = ui.status.textContent || '';
                                 if (!currentState.includes('Ready:') && !currentState.includes('worker connected')) {
                                      console.log("Setting UI state to worker_ready for general status"); // <-- ADDED LOG
                                      setUIState('worker_ready', 'AI worker connected.');
                                 }
                             }
                        }
                        break;
                    case 'answer_chunk':
                        // If it's not a thought and the stream isn't active yet, remove thinking bubble
                        if (!isThought && !streamingState[targetKey]?.active) { removeThinkingBubble(); }
                        // Initialize stream state if it's the first chunk
                        if (!streamingState[targetKey]?.active) {
                            streamingState[targetKey] = { active: true, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '', isCode: false };
                            if (isThought) {
                                const thoughtElements = addMessage('', 'ai', targetKey); // Create thought bubble elements
                                Object.assign(streamingState[targetKey], thoughtElements); // Store elements in state
                            }
                            // Start rendering interval if not already running
                            if (!renderInterval) { renderInterval = setInterval(renderCharacters, RENDER_SPEED); }
                        }
                        // Append data to buffer if stream state exists
                        if (streamingState[targetKey]) { streamingState[targetKey].textBuffer += message.data; }
                        break;
                    case 'answer_end':
                         // Mark stream as ended if state exists
                         if (streamingState[targetKey]) {
                            streamingState[targetKey].ended = true;
                            // Update thoughts summary text if applicable
                            if (isThought && streamingState[targetKey].summary) { streamingState[targetKey].summary.textContent = 'View Thinking Process (Finished)'; }
                         } else { console.warn(`Received answer_end for inactive stream: ${targetKey}`); }
                        break;
                    case 'error':
                        console.error("Received error message:", message.data); // Log error
                        finalizeStream(mainTarget, true); // Finalize stream as error
                        showRetryButton(mainTarget, message.data || "An unknown error occurred."); // Show retry button
                        cleanupStreaming(); // Cleanup all streams on error
                        // Reset UI state based on connection, but prioritize showing the error
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            if (currentPDFName && activeTab === 'pdf_chat') {
                                // Keep 'Ready' status if PDF was loaded, despite error in response
                                setUIState('ready_to_chat', `Ready: ${currentPDFName} (Error in response)`);
                            } else {
                                setUIState('worker_ready', 'AI worker connected (Error in response).');
                            }
                        } else {
                             setUIState('error', 'Connection error occurred.');
                        }
                        break;
                    case 'pong': break; // Ignore pongs
                    default:
                         console.warn("‚ö†Ô∏è Unknown message type:", message.type, message);
                         removeThinkingBubble(); // Remove thinking bubble for unknown types
                }
            }

            function renderCharacters() {
                 const renderSpeed = fastMode ? 999999 : CHARS_PER_TICK;
                let anyActiveStreams = false;

                for (let key in streamingState) {
                    const state = streamingState[key];
                    if (!key || !state || !state.active) continue;
                    anyActiveStreams = true;

                     const isThought = key.endsWith('_thoughts');
                     const mainChatKey = isThought ? key.replace('_thoughts', '_chat') : key;
                     const thoughtKey = mainChatKey.replace('_chat', '_thoughts'); // Define thoughtKey here

                     // Create the main answer bubble as soon as the first chunk arrives,
                     // regardless of the thoughts stream state.
                     if (!isThought && !state.bubble) {
                         const answerElements = addMessage('', 'ai', mainChatKey);
                         if(answerElements) Object.assign(state, answerElements);
                     }


                    if ((state.textBuffer.length > 0 || state.ended) && state.contentDiv) {
                        const charsToRender = Math.min(state.textBuffer.length, renderSpeed);
                        const chunk = state.textBuffer.substring(0, charsToRender);
                        state.currentText += chunk; state.textBuffer = state.textBuffer.substring(charsToRender);

                        // Ensure marked.parse is used safely
                        try {
                             state.contentDiv.innerHTML = marked.parse(state.currentText || ''); // Add fallback for safety
                        } catch (e) {
                            console.error("Markdown parsing error:", e, state.currentText);
                            // Fallback to plain text on error
                            state.contentDiv.textContent = state.currentText || '';
                        }


                        if (!isThought) {
                            state.contentDiv.querySelectorAll('pre').forEach(pre => {
                                if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                    const codeText = pre.textContent;
                                    // More robust check for code block structure
                                    if (codeText && codeText.trim().startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) {
                                        pre.outerHTML = renderCodeBlock(codeText);
                                    }
                                }
                            });
                             addCopyButtonsTo(state.contentDiv);
                        }

                        const container = key.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;
                        // Check if container exists before scrolling
                        if (container && container.scrollHeight - container.scrollTop <= container.clientHeight + 150) {
                             container.scrollTop = container.scrollHeight;
                        }
                    }

                    if (state.ended && state.textBuffer.length === 0) {
                        finalizeStream(key);
                        // Re-check if any streams are still active after finalizing one
                        // anyActiveStreams = Object.values(streamingState).some(s => s?.active);
                        // ^-- This check moves to finalizeStream to ensure UI state updates correctly
                    }
                }

                // *** REMOVED UI state update from here - moved to finalizeStream ***
                // if (!anyActiveStreams && renderInterval) { ... }
            }


             // *** THIS FUNCTION IS UPDATED ***
             function finalizeStream(target, isError = false) {
                 if (!target || !streamingState[target]) { console.warn(`Attempt to finalize invalid stream: ${target}`); return; }
                 const state = streamingState[target];
                 // Skip if already inactive (could happen if called twice)
                 if (!state.active) return;

                 const isThought = target.endsWith('_thoughts');
                 // Only remove thinking bubble if the MAIN CHAT stream ends
                 if (!isThought) removeThinkingBubble();

                 // Render any remaining text in the buffer
                 if (state.contentDiv && state.textBuffer.length > 0) {
                     state.currentText += state.textBuffer;
                     state.textBuffer = '';
                 }
                 const text = state.currentText.trim();

                 // Final render and history/autosave
                 if (state.contentDiv) {
                     try {
                        state.contentDiv.innerHTML = marked.parse(text || ''); // Add fallback
                     } catch(e) {
                         console.error("Markdown parsing error in finalizeStream:", e, text);
                         state.contentDiv.textContent = text || ''; // Fallback
                     }

                     if (!isThought) {
                          state.contentDiv.querySelectorAll('pre:not(.line-numbers pre):not(.code-content pre)').forEach(pre => {
                              if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                  const codeText = pre.textContent.replace(/Copy$/,'').trim();
                                   if (codeText && codeText.startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) { pre.outerHTML = renderCodeBlock(codeText); }
                              }
                          });
                          addCopyButtonsTo(state.contentDiv);
                          // --- Save to History ---
                          if (!isError && text.length > 0) {
                              const history = target.startsWith('ai_') ? aiChatHistory : pdfChatHistory;
                              const lastMsg = history.length > 0 ? history[history.length - 1] : null;
                              if (!lastMsg || lastMsg.sender !== 'ai' || lastMsg.text !== text) {
                                  history.push({ sender: 'ai', text: text, imageB64: null });
                                  autosaveChat();
                              }
                          }
                     } else if (state.summary) { state.summary.textContent = 'View Thinking Process (Finished)'; }
                 } else if (!isThought && !isError && text.length > 0) { // Handle case where bubble might not exist if error occurred early
                       const history = target.startsWith('ai_') ? aiChatHistory : pdfChatHistory;
                       const lastMsg = history.length > 0 ? history[history.length - 1] : null;
                       if (!lastMsg || lastMsg.sender !== 'ai' || lastMsg.text !== text) { history.push({ sender: 'ai', text: text, imageB64: null }); autosaveChat(); }
                  }

                 // Mark this specific stream as inactive *before* checking others
                 cleanupStreaming(target);

                 // *** NEW LOGIC TO RESET UI STATE ***
                 // Determine the keys for the main chat and thoughts for the *current active tab*
                 const mainChatKey = activeTab === 'ai_chat' ? 'ai_chat' : 'pdf_chat';
                 const thoughtKey = activeTab === 'ai_chat' ? 'ai_thoughts' : 'pdf_thoughts';

                 // Check if BOTH streams related to the current tab are now inactive
                 const mainStreamInactive = !streamingState[mainChatKey] || !streamingState[mainChatKey].active;
                 const thoughtStreamInactive = !streamingState[thoughtKey] || !streamingState[thoughtKey].active;

                 if (mainStreamInactive && thoughtStreamInactive && !isError) {
                     // Only reset to 'ready' if both streams for the active tab are done and no error occurred
                     console.log(`Both streams for ${activeTab} finished. Resetting UI state.`);
                     // *** ADD CHECK: Only reset if not currently processing a PDF ***
                     const currentStatusText = ui.status.textContent || '';
                     if (!currentStatusText.includes('Processing')) {
                         console.log("Resetting UI state as no PDF processing is active.");
                         if (currentPDFName && activeTab === 'pdf_chat') {
                             setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                         } else {
                             setUIState('worker_ready', 'AI worker connected.');
                         }
                     } else {
                         console.log("Streams finished, but PDF processing is active. Not resetting UI state yet.");
                     }
                 } else if (isError) {
                     // If an error occurred, reset state based on connection status (already done in handleServerMessage error case)
                     console.log("Error occurred during stream, UI state handled by error case.");
                 } else {
                     console.log(`Stream ${target} finished, but other streams for ${activeTab} might still be active. Not resetting UI state yet.`);
                 }
                 // *** END OF NEW LOGIC ***
            }


            function cleanupStreaming(target) {
                 const isThought = target?.endsWith('_thoughts');
                 // Remove thinking bubble only when the MAIN chat stream is cleaned up
                 if (!isThought && target?.endsWith('_chat')) {
                      // Don't remove thinking bubble here, let finalizeStream handle it
                      // removeThinkingBubble();
                  }

                if (!target) { // Cleanup all
                     removeThinkingBubble(); // Ensure removal if cleaning all
                     Object.keys(streamingState).forEach(key => {
                         if (streamingState[key]) { // Check key exists
                             streamingState[key] = { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '', isCode: false };
                         }
                     });
                     if (renderInterval) { clearInterval(renderInterval); renderInterval = null; } // Clear interval when cleaning all
                 } else if (streamingState[target]) { // Cleanup specific
                     streamingState[target] = { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '', isCode: false };
                 }

                 // Check if *any* stream is still active
                let anyActive = Object.values(streamingState).some(s => s?.active);
                // If no streams are active *at all*, clear the interval
                if (!anyActive && renderInterval) {
                     clearInterval(renderInterval);
                     renderInterval = null;
                     console.log("All streams inactive, clearing render interval.");
                 }
             }

            // --- Error Handling ---
            function showRetryButton(tab, errorMsg) {
                const errorContainer = tab === 'pdf_chat' ? ui.errorRetryContainerPdf : ui.errorRetryContainerAi;
                const targetChatContainer = tab === 'pdf_chat' ? ui.chatContainer : ui.chatContainerAI;
                removeThinkingBubble(); // Ensure thinking bubble is gone on error

                errorContainer.innerHTML = ''; // Clear previous button
                 const existingErrorBubbles = targetChatContainer.querySelectorAll('.error-bubble-container');
                 existingErrorBubbles.forEach(b => b.remove()); // Clear previous messages


                const errorBubbleContainer = document.createElement('div');
                errorBubbleContainer.className = 'error-bubble-container flex justify-start mb-2 px-4 w-full';
                 // Sanitize error message slightly for display
                const displayError = String(errorMsg).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                errorBubbleContainer.innerHTML = `<div class="chat-bubble bg-red-600 text-white p-3 rounded-lg ai-bubble"> **üö® ERROR**: ${displayError} </div>`;
                targetChatContainer.appendChild(errorBubbleContainer);

                errorContainer.style.display = 'flex';
                errorContainer.innerHTML = `<button id="retry-button-${tab}" class="retry-button"> ‚ôªÔ∏è Retry Last Prompt </button>`;
                // Ensure the button click handler is attached correctly
                 const retryButton = document.getElementById(`retry-button-${tab}`);
                 if (retryButton) {
                    retryButton.onclick = () => retryLastMessage(tab);
                } else {
                     console.error("Could not find retry button element");
                 }


                targetChatContainer.scrollTop = targetChatContainer.scrollHeight;
            }

            function retryLastMessage(tab) {
                 if (!lastUserMessageText && !lastUserMessageImageB64) return;
                ui.errorRetryContainerPdf.style.display = 'none'; ui.errorRetryContainerAi.style.display = 'none';
                const chatContainer = tab === 'pdf_chat' ? ui.chatContainer : ui.chatContainerAI;
                const errorBubbles = chatContainer.querySelectorAll('.error-bubble-container');
                errorBubbles.forEach(b => b.remove());

                sendMessage(lastUserMessageText, tab, lastUserMessageImageB64, true); // Send as retry
            }

            // --- Chat History Management ---
            async function autosaveChat() { /* ... (Uses fetchWithAuth) ... */
                const token = localStorage.getItem('ai_toolkit_token');
                const historyToSave = (activeTab === 'ai_chat') ? aiChatHistory : pdfChatHistory;
                if (!historyToSave || historyToSave.length === 0) return; // Add check for history array

                // Ensure history has valid structure before saving
                 const validHistory = historyToSave.filter(msg => msg && msg.sender && typeof msg.text === 'string');
                 if (validHistory.length === 0) return; // Don't save empty/invalid history


                const firstUserMessage = validHistory.find(m => m.sender === 'user')?.text || 'New Chat'; // Use valid history
                const chatName = (activeTab === 'pdf_chat' && currentPDFName) ? `${currentPDFName.replace('.pdf', '')}` : firstUserMessage.substring(0, 30);
                let chatId = (activeTab === 'ai_chat') ? sessionStorage.getItem('currentAIChatId') : sessionStorage.getItem('currentPdfChatId');

                if (!chatId) {
                    chatId = `chat_${Date.now()}`;
                    if (activeTab === 'ai_chat') sessionStorage.setItem('currentAIChatId', chatId);
                    else sessionStorage.setItem('currentPdfChatId', chatId);
                }

                const chatData = {
                    id: chatId, name: chatName, type: activeTab,
                    timestamp: new Date().toISOString(), history: validHistory, // Save validated history
                    pdfName: (activeTab === 'pdf_chat') ? currentPDFName : null
                };

                if (token) {
                    try {
                        // Debounce saving? Or save on every AI response. Let's save on every response for now.
                        await fetchWithAuth(`${RENDER_API_BASE_URL}/chats`, { method: 'POST', body: JSON.stringify(chatData) });
                        console.log("Chat saved to backend:", chatId);
                    } catch (error) { /* Error logged by fetchWithAuth */ }
                } else {
                    const storageKey = `${guestId}_${chatId}`;
                    // Use try-catch for localStorage in case it's blocked (e.g., incognito)
                    try {
                        localStorage.setItem(storageKey, JSON.stringify(chatData));
                        console.log(`Guest chat saved locally: ${storageKey}`);
                    } catch (e) {
                         console.warn("Could not save guest chat to localStorage:", e.message);
                    }
                }
             }

            async function loadSavedChats() { /* ... (Uses fetchWithAuth) ... */
                const token = localStorage.getItem('ai_toolkit_token');
                ui.sidebarTitle.textContent = activeTab === 'pdf_chat' ? "Saved PDF Chats" : "Saved AI Chats";
                ui.savedChatsList.innerHTML = '<p class="text-slate-400 text-sm px-2">Loading...</p>'; // Loading indicator
                let chats = [];

                try {
                    if (token) {
                        const fetchedChats = await fetchWithAuth(`${RENDER_API_BASE_URL}/chats`);
                        chats = fetchedChats ? fetchedChats.filter(chat => chat.type === activeTab) : [];
                        console.log("Fetched chats from backend:", chats.length);
                    } else {
                        // Use try-catch for localStorage
                        try {
                            guestId = localStorage.getItem('ai_toolkit_user_id');
                            if (guestId) { // Only try if guestId exists
                                for (let i = 0; i < localStorage.length; i++) {
                                    const key = localStorage.key(i);
                                    if (key.startsWith(`${guestId}_chat_`)) {
                                        try { const chat = JSON.parse(localStorage.getItem(key)); if (chat.type === activeTab) chats.push(chat); }
                                        catch (e) { console.error(`Error parsing localStorage key ${key}:`, e); localStorage.removeItem(key); } // Remove invalid item
                                    }
                                }
                            }
                            console.log("Loaded guest chats from localStorage:", chats.length);
                        } catch (e) {
                             console.warn("Could not load guest chats from localStorage:", e.message);
                             ui.savedChatsList.innerHTML = '<p class="text-slate-400 text-sm px-2">Guest chat history unavailable (localStorage blocked).</p>';
                             return; // Stop if localStorage is blocked
                        }
                    }
                } catch (error) { ui.savedChatsList.innerHTML = '<p class="text-red-400 text-sm px-2">Error loading chats.</p>'; return; }

                ui.savedChatsList.innerHTML = '';
                chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                if (chats.length === 0) { ui.savedChatsList.innerHTML = '<p class="text-slate-400 text-sm px-2">No saved chats yet.</p>'; }
                else {
                    chats.forEach(chat => {
                         if (!chat || !chat.id) return; // Skip invalid chat data
                        const item = document.createElement('div');
                        item.className = 'sidebar-chat-item p-2 bg-slate-700 rounded-md cursor-pointer hover:bg-slate-600 truncate flex justify-between items-center text-sm';
                        const nameSpan = document.createElement('span'); nameSpan.textContent = chat.name || "Chat";
                        nameSpan.className = "overflow-hidden text-ellipsis whitespace-nowrap flex-grow mr-2";
                        item.appendChild(nameSpan);
                        const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-chat-btn flex-shrink-0'; deleteBtn.innerHTML = '&times;';
                        const identifier = token ? chat.id : `${guestId}_${chat.id}`;
                        item.onclick = () => loadChat(identifier); // Use identifier
                        deleteBtn.onclick = (e) => { e.stopPropagation(); if (window.confirm(`Delete "${chat.name || 'Chat'}"? This cannot be undone.`)) { deleteChat(identifier); } }; // Use identifier
                        item.appendChild(deleteBtn); ui.savedChatsList.appendChild(item);
                    });
                }
             }

            async function loadChat(identifier) { /* ... (Uses fetchWithAuth) ... */
                 const token = localStorage.getItem('ai_toolkit_token');
                 let chatData = null;
                 const chatIdToLoad = token ? identifier : identifier.split('_').pop();

                 console.log(`Loading chat: ${identifier} (ID: ${chatIdToLoad})`);
                 cleanupStreaming();

                try {
                    if (token) { chatData = await fetchWithAuth(`${RENDER_API_BASE_URL}/chats/${chatIdToLoad}`); }
                    else {
                        // Use try-catch for localStorage
                         try {
                              chatData = JSON.parse(localStorage.getItem(identifier));
                         } catch (e) {
                              console.warn("Could not load guest chat from localStorage:", e.message);
                              throw new Error("Could not load chat data (localStorage blocked?).");
                         }
                    }

                     if (!chatData) { throw new Error("Chat data not found."); } // Throw error if null
                     if (!chatData.history || !Array.isArray(chatData.history)) { // Validate history
                          console.warn("Loaded chat data missing or invalid history array:", chatData);
                          chatData.history = []; // Reset history if invalid
                     }


                    activeTab = chatData.type;
                    const currentChatIdKey = activeTab === 'ai_chat' ? 'currentAIChatId' : 'currentPdfChatId';
                    sessionStorage.setItem(currentChatIdKey, chatData.id);

                    // Update UI tabs state
                    if(activeTab === 'pdf_chat'){
                         ui.viewChatPDF.style.display = 'grid'; ui.viewAIChat.style.display = 'none';
                         ui.tabChatPDF.classList.add('active'); ui.tabAIChat.classList.remove('active');
                         pdfChatHistory = chatData.history; currentPDFName = chatData.pdfName;
                         renderHistory(pdfChatHistory, 'pdf_chat');
                         ui.pdfTitle.textContent = currentPDFName || 'PDF Preview'; ui.pdfViewer.src = '';
                         if (currentPDFName) {
                             addMessage(`Chat loaded. Please re-upload "${currentPDFName}" to continue.`, 'system', 'pdf_chat');
                             setUIState('worker_ready', `Loaded: '${currentPDFName}'. Re-upload needed.`);
                         } else { setUIState('worker_ready', 'AI worker connected.'); }
                    } else { // ai_chat
                        ui.viewChatPDF.style.display = 'none'; ui.viewAIChat.style.display = 'flex';
                        ui.tabChatPDF.classList.remove('active'); ui.tabAIChat.classList.add('active');
                        aiChatHistory = chatData.history;
                        renderHistory(aiChatHistory, 'ai_chat');
                        setUIState('worker_ready', 'AI worker connected.');
                    }
                    ui.sidebar.classList.add('-translate-x-full');

                } catch (error) {
                     console.error("Failed to load chat:", error);
                     addMessage(`Error: Could not load chat. ${error.message}`, 'system', activeTab);
                 }
             }

            async function deleteChat(identifier) { /* ... (Uses fetchWithAuth) ... */
                 const token = localStorage.getItem('ai_toolkit_token');
                 const chatIdToDelete = token ? identifier : identifier.split('_').pop();

                try {
                    if (token) { await fetchWithAuth(`${RENDER_API_BASE_URL}/chats/${chatIdToDelete}`, { method: 'DELETE' }); console.log(`Chat deleted from backend: ${chatIdToDelete}`); }
                    else {
                        // Use try-catch for localStorage
                        try {
                             localStorage.removeItem(identifier);
                             console.log(`Guest chat deleted locally: ${identifier}`);
                        } catch (e) {
                             console.warn("Could not delete guest chat from localStorage:", e.message);
                             // Optionally inform the user
                             addMessage("Could not delete chat (localStorage blocked?).", 'system', activeTab);
                             loadSavedChats(); // Refresh list even on error
                             return;
                        }
                    }

                    const currentChatIdKey = activeTab === 'ai_chat' ? 'currentAIChatId' : 'currentPdfChatId';
                    const currentChatId = sessionStorage.getItem(currentChatIdKey);

                    if (currentChatId === chatIdToDelete) { startNewChat(); } // If deleting active chat, clear view
                     else { loadSavedChats(); } // Otherwise, just refresh the list

                } catch (error) { /* Error logged by fetchWithAuth */ }
             }

             function startNewChat() {
                 const currentChatIdKey = activeTab === 'ai_chat' ? 'currentAIChatId' : 'currentPdfChatId';
                 sessionStorage.removeItem(currentChatIdKey); // Clear active chat ID

                 // Clear history arrays and UI specific to the active tab
                 if (activeTab === 'pdf_chat') {
                     pdfChatHistory = []; currentPDFName = null;
                     ui.chatContainer.innerHTML = ''; ui.pdfTitle.textContent = 'PDF Preview'; ui.pdfViewer.src = '';
                 } else {
                     aiChatHistory = []; ui.chatContainerAI.innerHTML = '';
                 }

                 cleanupStreaming(); // Clear any active streams
                 ui.messageInput.value = ''; ui.messageInputAI.value = '';
                 ui.imagePreviewContainerAI.style.display = 'none'; ui.imageUploadAI.value = ''; uploadedImageB64 = null;
                 ui.errorRetryContainerPdf.style.display = 'none'; ui.errorRetryContainerAi.style.display = 'none'; // Hide errors

                 // Re-check status to potentially enable inputs, but don't force 'worker_ready'
                 // Let the checkWorkerStatus -> connectWebSocket -> onmessage flow handle the final UI state
                 checkWorkerStatus();
                 loadSavedChats(); // Refresh sidebar (will show 'No chats' if empty after clearing)
             }

            // --- Other UI Handlers ---
             function renderHistory(history, target = 'pdf_chat') {
                 const container = (target === 'ai_chat') ? ui.chatContainerAI : ui.chatContainer;
                 container.innerHTML = ''; // Clear before rendering
                 if (!history || history.length === 0) { return; }

                 history.forEach(msg => {
                     if (!msg || !msg.sender) return; // Skip invalid messages
                     const bubble = document.createElement('div');
                     if (msg.sender === 'system') {
                          bubble.classList.add('text-center', 'text-xs', 'text-slate-400', 'my-2', 'px-4'); // Add padding
                          bubble.textContent = msg.text;
                     } else {
                         bubble.classList.add('chat-bubble', 'p-3', 'w-fit', 'my-1'); // Simplified classes
                         // *** Re-applying the classList.add fix here just in case ***
                         if (msg.sender === 'user') {
                            bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                         } else {
                            bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                         }

                         const textNode = document.createElement('div');
                         if (msg.sender === 'ai') {
                              // Use try-catch for marked.parse
                              let finalHtml = '';
                              try {
                                   finalHtml = marked.parse(msg.text || '');
                              } catch(e) {
                                   console.error("Markdown parsing error:", e);
                                   finalHtml = (msg.text || '').replace(/</g, "&lt;").replace(/>/g, "&gt;"); // Basic escape on error
                              }

                              const tempDiv = document.createElement('div'); tempDiv.innerHTML = finalHtml;
                              tempDiv.querySelectorAll('pre:not(.line-numbers pre):not(.code-content pre)').forEach(pre => {
                                  if (pre.querySelector('code') && !pre.closest('.code-block-container')) {
                                      const codeText = pre.textContent.replace(/Copy$/,'').trim(); // More robustly remove 'Copy'
                                      // Check if it looks like a fenced block more reliably
                                      if (codeText && codeText.startsWith('```') && codeText.includes('\n') && codeText.trim().endsWith('```')) {
                                           pre.outerHTML = renderCodeBlock(codeText);
                                      }
                                  }
                              });
                              finalHtml = tempDiv.innerHTML; textNode.innerHTML = finalHtml;
                              // Defer copy button attachment slightly
                              setTimeout(() => addCopyButtonsTo(bubble), 10);
                         } else { textNode.textContent = msg.text || ''; } // User messages plain text, handle undefined
                         bubble.appendChild(textNode);
                         if (msg.sender === 'user' && msg.imageB64) {
                             const img = document.createElement('img'); img.src = `data:image/jpeg;base64,${msg.imageB64}`;
                              img.className = 'mt-2 rounded max-w-xs'; // Style image
                             bubble.appendChild(img);
                         }
                     }
                     container.appendChild(bubble);
                 });
                 // Scroll to bottom after rendering
                 requestAnimationFrame(() => { // Use requestAnimationFrame for smoother scroll after render
                    if (container) container.scrollTop = container.scrollHeight;
                 });
             }


            async function uploadPDF() {
                const file = ui.pdfUploadInput.files[0]; if (!file) return;
                startNewChat();
                currentPDFName = file.name; ui.pdfTitle.textContent = currentPDFName;
                ui.pdfViewer.src = URL.createObjectURL(file);
                setUIState('processing', `Processing '${file.name}'...`);
                addMessage(`Uploading "${file.name}"...`, 'system', 'pdf_chat');
                let user_id; const token = localStorage.getItem('ai_toolkit_token');
                if (token) { const payload = JSON.parse(atob(token.split('.')[1])); user_id = payload.sub; }
                else { user_id = guestId; } // Use current guestId
                const formData = new FormData(); formData.append('file', file);
                try {
                    const response = await fetch(`${RENDER_API_BASE_URL}/upload/${user_id}`, { method: 'POST', body: formData });
                    if (!response.ok) {
                        let errorData;
                        try { errorData = await response.json(); } catch { errorData = { detail: response.statusText }; }
                        throw new Error(errorData.detail || 'Failed to start PDF processing.');
                    }
                     // Worker will send 'Processing...' status message
                } catch (error) { addMessage(`Upload Error: ${error.message}`, 'system', 'pdf_chat'); setUIState('worker_ready', 'Upload failed.'); currentPDFName = null; ui.pdfTitle.textContent = 'PDF Preview'; ui.pdfViewer.src = '';} // Reset on failure
             }

            function handleImageFile(file) {
                if (!file || !file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedImageB64 = event.target.result.split(',')[1];
                    ui.imagePreviewAI.src = event.target.result; ui.imagePreviewContainerAI.style.display = 'block';
                }; reader.readAsDataURL(file);
            }
            function toggleFastMode(button) {
                fastMode = !fastMode;
                [ui.fastModeButtonAi, ui.fastModeButtonPdf].forEach(btn => {
                    btn.classList.toggle('fast-active', fastMode);
                    btn.textContent = fastMode ? '‚ö° FAST MODE ACTIVE' : '‚ö° Fast Paste';
                });
                if (Object.values(streamingState).some(s => s?.active) && renderInterval) {
                     clearInterval(renderInterval);
                     renderInterval = setInterval(renderCharacters, fastMode ? 1 : RENDER_SPEED);
                }
             }
             
             function renderCodeBlock(codeText) {
                if (!codeText) return '<pre><code></code></pre>'; // Handle empty
                const lines = codeText.trim().split('\n');
                const langMatch = lines[0].match(/```(\w+)/);
                const language = langMatch ? langMatch[1] : '';
                
                // Ensure we only take code lines, even if no language is specified
                const codeLinesContent = (langMatch ? lines.slice(1, lines.length - 1) : lines.slice(0).filter(line => !line.startsWith('```'))).join('\n');
                
                const escapeHtml = (str) => (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                
                const codeHtml = codeLinesContent.split('\n').map(line => `<code>${escapeHtml(line)}</code>`).join('');
                const lineNumbers = codeLinesContent.split('\n').map((_, index) => index + 1).join('\n');
                
                return `
                    <div class="code-block-container">
                        ${language ? `<span class="language-tag">${language}</span>` : ''}
                        <ol>
                            <li class="line-numbers"><pre>${lineNumbers}</pre></li>
                            <li class="code-content"><pre>${codeHtml}</pre></li>
                        </ol>
                        <button class="copy-button">Copy</button>
                    </div>
                `;
            }
            
            function addCopyButtonsTo(containerElement) {
                containerElement.querySelectorAll('.code-block-container').forEach(blockContainer => {
                    // Check if a button has already been attached to avoid duplicates
                    if (blockContainer.querySelector('.copy-button.attached')) return;
                    
                    const codeElement = blockContainer.querySelector('.code-content'); // Get the whole code content
                    if (!codeElement) return;
                    
                    const button = blockContainer.querySelector('.copy-button');
                    if (button) {
                        button.classList.add('attached'); // Mark as attached
                        button.addEventListener('click', () => {
                            const code = codeElement.innerText; // Get text from the code element
                            // Use document.execCommand for broader compatibility
                            const textArea = document.createElement("textarea");
                            textArea.value = code;
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                button.textContent = 'Copied!';
                            } catch (err) {
                                console.error('Fallback: Oops, unable to copy', err);
                                button.textContent = 'Error';
                            }
                            document.body.removeChild(textArea);
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    }
                });
                
                // Also add copy buttons to regular <pre> tags that aren't part of a line-numbered block
                containerElement.querySelectorAll('pre').forEach(block => {
                    if (block.closest('.code-block-container')) return; // Already handled
                    if (block.querySelector('.copy-button.attached')) return; // Already attached
                    
                    const button = document.createElement('button');
                    button.className = 'copy-button attached'; // Add 'attached'
                    button.textContent = 'Copy';
                    // Style it to be inside the <pre>
                    block.style.position = 'relative';
                    block.appendChild(button);
                    
                    button.addEventListener('click', () => {
                        // Get text, attempting to find a <code> tag first
                        const code = block.querySelector('code')?.innerText || block.innerText;
                        // Clean the "Copy" text out if it got included
                        const cleanedCode = code.replace(/Copy$/, '').trim();
                        
                         // Use document.execCommand for broader compatibility
                        const textArea = document.createElement("textarea");
                        textArea.value = cleanedCode;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                             button.textContent = 'Copied!';
                        } catch (err) {
                            console.error('Fallback: Oops, unable to copy', err);
                            button.textContent = 'Error';
                        }
                        document.body.removeChild(textArea);
                        setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                    });
                });
            }


            // --- Event Listeners (FINAL PLACEMENT) ---
             // Add input listeners to enable/disable auth submit button
            ui.usernameInput.addEventListener('input', () => {
                 ui.authSubmitButton.disabled = !(ui.usernameInput.value.trim() && ui.passwordInput.value.trim());
            });
             ui.passwordInput.addEventListener('input', () => {
                 ui.authSubmitButton.disabled = !(ui.usernameInput.value.trim() && ui.passwordInput.value.trim());
            });

            ui.tabChatPDF.addEventListener('click', () => {
                 if (activeTab === 'pdf_chat') return;
                 cleanupStreaming(); activeTab = 'pdf_chat';
                 ui.viewChatPDF.style.display = 'grid'; ui.viewAIChat.style.display = 'none';
                 ui.tabChatPDF.classList.add('active'); ui.tabAIChat.classList.remove('active');
                 startNewChat(); loadSavedChats();
             });
            ui.tabAIChat.addEventListener('click', () => {
                 if (activeTab === 'ai_chat') return;
                 cleanupStreaming(); activeTab = 'ai_chat';
                 ui.viewChatPDF.style.display = 'none'; ui.viewAIChat.style.display = 'flex';
                 ui.tabChatPDF.classList.remove('active'); ui.tabAIChat.classList.add('active');
                 startNewChat(); loadSavedChats();
             });
            ui.openSidebarButton.addEventListener('click', () => { loadSavedChats(); ui.sidebar.classList.remove('-translate-x-full'); });
            ui.closeSidebarButton.addEventListener('click', () => ui.sidebar.classList.add('-translate-x-full') );
            ui.newChatButton.addEventListener('click', () => { startNewChat(); ui.sidebar.classList.add('-translate-x-full'); });
            ui.pdfUploadInput.addEventListener('change', uploadPDF);
            ui.imageUploadAI.addEventListener('change', (e) => handleImageFile(e.target.files[0]));
            ui.removeImageButtonAI.addEventListener('click', () => { uploadedImageB64 = null; ui.imagePreviewContainerAI.style.display = 'none'; ui.imageUploadAI.value = ''; });
            ui.messageInputAI.addEventListener('paste', (e) => {
                const items = (e.clipboardData || window.clipboardData).items;
                for (const item of items) { if (item.kind === 'file' && item.type.startsWith('image/')) { e.preventDefault(); const file = item.getAsFile(); handleImageFile(file); return; } }
            });
            ui.sendButton.addEventListener('click', () => sendMessage(ui.messageInput.value, 'pdf_chat'));
            ui.messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(ui.messageInput.value, 'pdf_chat'); } });
            ui.sendButtonAI.addEventListener('click', () => sendMessage(ui.messageInputAI.value, 'ai_chat', uploadedImageB64));
            ui.messageInputAI.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(ui.messageInputAI.value, 'ai_chat', uploadedImageB64); } });
            ui.fastModeButtonPdf.addEventListener('click', () => toggleFastMode(ui.fastModeButtonPdf));
            ui.fastModeButtonAi.addEventListener('click', () => toggleFastMode(ui.fastModeButtonAi));
            ui.authForm.addEventListener('submit', handleAuthSubmit);
            ui.logoutButton.addEventListener('click', handleLogout);
            ui.loginButton.addEventListener('click', () => { isLoginMode = true; ui.authTitle.textContent = 'Login'; ui.authSubmitButton.textContent = 'Login'; ui.authSwitchButton.textContent = 'Need an account? Sign up'; ui.authSubmitButton.disabled = true; showAuthModal(true); });
            ui.authCloseButton.addEventListener('click', () => showAuthModal(false));
            ui.authSwitchButton.addEventListener('click', () => {
                 isLoginMode = !isLoginMode; ui.authTitle.textContent = isLoginMode ? 'Login' : 'Sign Up';
                 ui.authSubmitButton.textContent = isLoginMode ? 'Login' : 'Sign Up';
                 ui.authSwitchButton.textContent = isLoginMode ? 'Need an account? Sign up' : 'Have an account? Login';
                 ui.authError.style.display = 'none'; ui.authForm.reset();
                 ui.authSubmitButton.disabled = true; // Start disabled on switch
                 // ui.authSubmitButton.disabled = !(ui.usernameInput.value.trim() && ui.passwordInput.value.trim()); // Re-evaluate immediately - removed, handled by input listeners
            });

            // --- Initial Load ---
            updateAuthUI();
            activeTab = 'pdf_chat'; ui.viewChatPDF.style.display = 'grid'; ui.viewAIChat.style.display = 'none';
            ui.tabChatPDF.classList.add('active'); ui.tabAIChat.classList.remove('active');
            // Start connection check, it will handle loading chats after successful connection/auth
            checkWorkerStatus();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
" selected code.

make it so that the app.py code is updated to save chats to firebase not the local storage

