<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Toolkit</title>
    <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
    <script src="[https://cdn.jsdelivr.net/npm/marked/marked.min.js](https://cdn.jsdelivr.net/npm/marked/marked.min.js)"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 90%; word-wrap: break-word; white-space: pre-wrap; }
        .user-bubble { background-color: #2563eb; color: white; }
        .ai-bubble { background-color: #334155; color: #f1f5f9; }
        
        /* --- STYLES FOR THOUGHTS BUBBLE --- */
        .thoughts-bubble { 
            background-color: #1e293b; 
            color: #94a3b8; 
            font-size: 0.9rem;
            border-left: 3px solid #6366f1;
            padding: 0.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .thoughts-bubble details > summary {
            list-style: none;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            outline: none;
            color: #a5b4fc;
            font-weight: 600;
        }
        .thoughts-bubble details[open] > summary {
            border-bottom: 1px solid #475569;
            margin-bottom: 0.5rem;
        }
        .thoughts-content pre { 
            background-color: #0f172a; 
            padding: 0.75rem; 
            border-radius: 0.375rem; 
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        /* --- STYLES FOR SPEED BUTTON --- */
        .speed-button {
            background-color: #6366f1;
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            opacity: 0.8;
            font-weight: 600;
        }
        .speed-button:hover {
            opacity: 1;
            background-color: #4f46e5;
        }
        .speed-button.fast-active {
            background-color: #f59e0b;
        }

        /* --- STYLES FOR CODE BLOCK WITH LINE NUMBERS --- */
        .code-block-container {
            position: relative;
            background-color: #0f172a;
            border-radius: 0.5rem;
            margin: 1rem 0;
            padding: 0;
            overflow: hidden;
        }
        .code-block-container .language-tag {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #475569;
            color: #e2e8f0;
            padding: 0.1rem 0.5rem;
            font-size: 0.7rem;
            border-top-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            z-index: 10;
        }
        .code-block-container ol {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            font-size: 0.9rem;
        }
        .line-numbers {
            background-color: #1e293b;
            color: #64748b;
            text-align: right;
            padding: 1rem 0.5rem;
            user-select: none;
            line-height: 1.5;
        }
        .code-content {
            flex-grow: 1;
            padding: 1rem;
            overflow-x: auto;
        }
        .code-content code {
            display: block;
            white-space: pre;
            color: #e2e8f0;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
        }
        /* -------------------------------------- */

        #chat-sidebar { transition: transform 0.3s ease-in-out; }
        .tab-button.active { border-color: #4f46e5; color: #4f46e5; }
        

        #chat-container::-webkit-scrollbar,
        #chat-container-ai::-webkit-scrollbar,
        #saved-chats-list::-webkit-scrollbar { width: 8px; }

        #chat-container::-webkit-scrollbar-track,
        #chat-container-ai::-webkit-scrollbar-track,
        #saved-chats-list::-webkit-scrollbar-track { background: #1e293b; }

        #chat-container::-webkit-scrollbar-thumb,
        #chat-container-ai::-webkit-scrollbar-thumb,
        #saved-chats-list::-webkit-scrollbar-thumb { background: #475569; 
        border-radius: 4px; }
        

        .ai-bubble pre { background-color: #0f172a; color: #e2e8f0; 
        padding: 1rem; border-radius: 0.5rem; overflow-x: auto; position: 
        relative; }
        .ai-bubble code { font-family: 'Courier New', Courier, monospace; }
        .user-bubble img { max-width: 150px; border-radius: 0.5rem; margin-top: 0.5rem; }

        .copy-button { position: absolute; top: 0.5rem; right: 0.5rem; 
        background-color: #475569; color: white; border: none; padding: 0.25rem 
        0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.8rem; 
        opacity: 0; transition: opacity 0.2s; }
        pre:hover .copy-button { opacity: 1; }

        .ai-bubble table { width: 100%; margin-top: 1em; margin-bottom:
        1em; border-collapse: collapse; border: 1px solid #475569; }
        .ai-bubble th, .ai-bubble td { border: 1px solid #475569; padding: 0.5rem 0.75rem; text-align: left; }
        .ai-bubble th { background-color: #1e293b; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div class="flex h-full">

        <aside id="chat-sidebar" class="w-64 bg-slate-800 text-white
        flex flex-col p-4 transform -translate-x-full fixed h-full z-20">
            <div class="flex justify-between items-center mb-4 border-b border-slate-600 pb-2">
                <h2 id="sidebar-title" class="text-xl font-bold">Saved Chats</h2>

                <button id="close-sidebar-button" 
                class="text-slate-400 hover:text-white 
                text-2xl">&times;</button>
            </div>

            <button id="new-chat-button" class="w-full text-left p-2
            mb-2 bg-indigo-500 rounded-md hover:bg-indigo-600">Ôºã New 
            Chat</button>
            <div id="saved-chats-list" class="flex-1 overflow-y-auto space-y-2"></div>
        </aside>

        <div class="flex-1 flex flex-col h-full">
            <header class="bg-white shadow-md p-4 flex items-center justify-between z-10">
                <div class="flex items-center space-x-4">
                    <button id="open-sidebar-button" class="p-2 rounded-md hover:bg-gray-200">

                        <svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" 
                        class="h-6 w-6" fill="none" viewBox="0 0 24 24" 
                        stroke="currentColor"><path stroke-linecap="round" 
                        stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" 
                        /></svg>
                    </button>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-800">AI Toolkit</h1>
                        <p id="status" class="text-sm text-gray-500">Status: Connecting to server...</p>
                    </div>
                </div>
                <div>

                    <button id="tab-chatpdf" class="tab-button py-2 
                    px-4 text-gray-500 font-semibold border-b-2">ChatPDF</button>

                    <button id="tab-ai-chat" class="tab-button py-2 
                    px-4 text-gray-500 font-semibold border-b-2">AI Chat</button>
                </div>
            </header>

            <div id="view-chatpdf" class="flex-1 grid grid-cols-2 gap-4 p-4 overflow-hidden">
                <section class="bg-white rounded-lg shadow-md flex flex-col h-full">

                    <div class="p-2 border-b bg-gray-50"><h2 
                    id="pdf-title" class="text-lg font-bold text-gray-700 truncate">PDF 
                    Preview</h2></div>

                    <div class="flex-1 p-2"><embed 
                    id="pdf-viewer" src="" type="application/pdf" width="100%" 
                    height="100%"/></div>
                </section>
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">

                            <label for="pdf-upload" 
                            id="upload-label" class="cursor-not-allowed bg-gray-500 text-white 
                            font-bold py-2 px-4 rounded-lg">üìÅ Upload</label>
                            <input id="pdf-upload" type="file" class="hidden" accept=".pdf" disabled>
                            
                            <button id="fast-mode-button-pdf" class="speed-button">‚ö° Fast Paste</button>

                            <input type="text" id="message-input" 
                            class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg
                            p-2" placeholder="Please connect to worker..." disabled>

                            <button id="send-button" 
                            class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" 
                            disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>

            <div id="view-ai-chat" style="display: none;" class="flex-1 flex flex-col p-4 overflow-hidden">
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container-ai" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <div id="image-preview-container-ai" class="p-4 pt-0" style="display: none;">
                        <div class="relative w-24 h-24">
                            <img id="image-preview-ai" class="w-full h-full object-cover rounded-md">

                            <button id="remove-image-button-ai" 
                            class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6
                            flex items-center justify-center -mt-2 
                            -mr-2">&times;</button>
                        </div>
                    </div>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">
                            <label for="image-upload-ai" class="cursor-pointer text-slate-400 hover:text-white p-2">

                                <svg 
                                xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="24" height="24" viewBox="0 0 
                                24 24" fill="none" stroke="currentColor" stroke-width="2" 
                                stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 
                                11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 
                                9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                            </label>
                            <input id="image-upload-ai" type="file" class="hidden" accept="image/jpeg,image/png">
                            
                            <button id="fast-mode-button-ai" class="speed-button">‚ö° Fast Paste</button>

                            <input type="text" id="message-input-ai"
                            class="flex-1 bg-slate-700 border border-slate-600 text-white 
                            rounded-lg p-2" placeholder="Please connect to worker..." disabled>

                            <button id="send-button-ai" 
                            class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" 
                            disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                status: document.getElementById('status'),
                sidebar: document.getElementById('chat-sidebar'),
                sidebarTitle: document.getElementById('sidebar-title'),
                openSidebarButton: document.getElementById('open-sidebar-button'),
                closeSidebarButton: document.getElementById('close-sidebar-button'),
                newChatButton: document.getElementById('new-chat-button'),
                savedChatsList: document.getElementById('saved-chats-list'),
                
                tabChatPDF: document.getElementById('tab-chatpdf'),
                tabAIChat: document.getElementById('tab-ai-chat'),
                viewChatPDF: document.getElementById('view-chatpdf'),
                viewAIChat: document.getElementById('view-ai-chat'),

                chatContainer: document.getElementById('chat-container'),
                messageInput: document.getElementById('message-input'),
                sendButton: document.getElementById('send-button'),
                pdfUploadInput: document.getElementById('pdf-upload'),
                uploadLabel: document.getElementById('upload-label'),
                pdfViewer: document.getElementById('pdf-viewer'),
                pdfTitle: document.getElementById('pdf-title'),

                chatContainerAI: document.getElementById('chat-container-ai'),
                messageInputAI: document.getElementById('message-input-ai'),
                sendButtonAI: document.getElementById('send-button-ai'),
                imageUploadAI: document.getElementById('image-upload-ai'),
                imagePreviewContainerAI: document.getElementById('image-preview-container-ai'),
                imagePreviewAI: document.getElementById('image-preview-ai'),
                removeImageButtonAI: document.getElementById('remove-image-button-ai'),
                
                // NEW BUTTON REFERENCES
                fastModeButtonPdf: document.getElementById('fast-mode-button-pdf'),
                fastModeButtonAi: document.getElementById('fast-mode-button-ai'),
            };
            
            let userId = localStorage.getItem('ai_toolkit_user_id') || `user_${Math.random().toString(36).substr(2, 9)}`;
            localStorage.setItem('ai_toolkit_user_id', userId);
            
            let pdfChatHistory = [];
            let aiChatHistory = [];
            let currentPDFName = null;
            let activeTab = 'pdf_chat';
            let uploadedImageB64 = null;
            
            // NEW GLOBAL STATE FOR FAST MODE
            let fastMode = false; 

            let socket, statusInterval, pingInterval;
            
            // --- UPDATED STREAM STATE TO MANAGE THOUGHTS SEPARATELY ---
            let streamingState = {
                pdf_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                ai_chat: { active: false, bubble: null, contentDiv: null, ended: false, textBuffer: '', currentText: '', isCode: false },
                // NEW: Stream state for thought process, including summary element
                pdf_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' },
                ai_thoughts: { active: false, bubble: null, contentDiv: null, summary: null, ended: false, textBuffer: '', currentText: '' }
            };

            // Render at a smooth, constant interval for a fluid, human-like typing effect
            let renderInterval = null;
            const RENDER_SPEED = 10; // milliseconds
            const CHARS_PER_TICK = 3;
            // -------------------------------------------------------------

            // NEW FUNCTION: Renders code block HTML with line numbers
            function renderCodeBlock(codeText) {
                const lines = codeText.trim().split('\n');
                const langMatch = lines[0].match(/```(\w+)/);
                const language = langMatch ? langMatch[1] : '';
                
                // Remove the start and end triple backticks
                const codeLines = lines.slice(1, lines.length - 1).join('\n');
                
                const codeHtml = codeLines.split('\n').map(line => `<code>${line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code>`).join('');
                
                const lineNumbers = codeLines.split('\n').map((_, index) => index + 1).join('\n');

                return `
                    <div class="code-block-container">
                        ${language ? `<span class="language-tag">${language}</span>` : ''}
                        <ol>
                            <li class="line-numbers"><pre>${lineNumbers}</pre></li>
                            <li class="code-content"><pre>${codeHtml}</pre></li>
                        </ol>
                        <button class="copy-button">Copy</button>
                    </div>
                `;
            }

            function setUIState(state, message = "") {
                ui.status.textContent = `Status: ${message}`;
                const isChatReady = state === 'ready_to_chat';
                const isWorkerReady = state === 'worker_ready' || isChatReady;
                
                ui.pdfUploadInput.disabled = !isWorkerReady;
                ui.uploadLabel.classList.toggle('cursor-not-allowed', !isWorkerReady);
                ui.uploadLabel.classList.toggle('cursor-pointer', isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-gray-500', !isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-blue-500', isWorkerReady);
                ui.uploadLabel.classList.toggle('hover:bg-blue-600', isWorkerReady);
                
                // Disable inputs if a stream is active or we are waiting on a worker
                const isPdfStreaming = streamingState.pdf_chat.active || streamingState.pdf_thoughts.active;
                const isAiStreaming = streamingState.ai_chat.active || streamingState.ai_thoughts.active;

                ui.messageInput.disabled = !isChatReady || isPdfStreaming;
                ui.sendButton.disabled = !isChatReady || isPdfStreaming;
                ui.messageInputAI.disabled = !isWorkerReady || isAiStreaming;
                ui.sendButtonAI.disabled = !isWorkerReady || isAiStreaming;

                if (isChatReady && !isPdfStreaming) {
                    ui.messageInput.placeholder = "Ask a question about the PDF...";
                    ui.sendButton.classList.remove('bg-gray-500'); 
                    ui.sendButton.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInput.placeholder = message;
                    ui.sendButton.classList.add('bg-gray-500'); 
                    ui.sendButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                }

                if (isWorkerReady && !isAiStreaming) {
                    ui.messageInputAI.placeholder = "Send a message, or paste an image...";
                    ui.sendButtonAI.classList.remove('bg-gray-500'); 
                    ui.sendButtonAI.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInputAI.placeholder = message;
                    ui.sendButtonAI.classList.add('bg-gray-500'); 
                    ui.sendButtonAI.classList.remove('bg-green-500', 'hover:bg-green-600');
                }
            }

            async function checkWorkerStatus() {
                try {
                    const response = await fetch(`/status`);
                    if (!response.ok) throw new Error("Server not reachable");
                    const data = await response.json();
                    if (data.worker_connected) {
                        setUIState('worker_ready', 'AI worker connected.');
                        clearInterval(statusInterval);
                        connectWebSocket();
                    } else {
                        setUIState('waiting_for_worker', 'Waiting for local AI worker...');
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                    setUIState('error', 'Could not connect to server.');
                }
            }

            function connectWebSocket() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws/web/${userId}`;
                console.log('Connecting to WebSocket:', wsUrl);
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log("‚úÖ WebSocket connected successfully");
                    if (pingInterval) clearInterval(pingInterval);
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 20000);
                };

                socket.onmessage = (event) => {
                    console.log("üì® Message received:", event.data);
                    try {
                        const message = JSON.parse(event.data);
                        handleServerMessage(message);
                    } catch (error) {
                        console.error("‚ùå Failed to handle message:", error, event.data);
                    }
                };
                
                socket.onclose = (event) => {
                    console.log("üîå WebSocket disconnected. Code:", event.code, "Reason:", event.reason);
                    clearInterval(pingInterval);
                    
                    // Clean up any ongoing streaming
                    cleanupStreaming();
                    
                    setUIState('disconnected', 'Disconnected. Trying to reconnect...');
                    if (statusInterval) clearInterval(statusInterval);
                    statusInterval = setInterval(checkWorkerStatus, 3000);
                };
                
                socket.onerror = (error) => {
                    console.error("‚ùå WebSocket Error:", error);
                };
            }

            function addCopyButtonsTo(containerElement) {
                containerElement.querySelectorAll('.code-block-container').forEach(blockContainer => {
                    if (blockContainer.querySelector('.copy-button.attached')) return;
                    
                    const codeElement = blockContainer.querySelector('.code-content code');
                    if (!codeElement) return;

                    const button = blockContainer.querySelector('.copy-button');
                    button.classList.add('attached');

                    button.addEventListener('click', () => {
                        const code = codeElement.innerText;
                        navigator.clipboard.writeText(code).then(() => {
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    });
                });
                
                // Legacy support for non-code pre blocks (tables/old markdown)
                containerElement.querySelectorAll('pre').forEach(block => {
                    if (block.querySelector('.copy-button.attached')) return;
                    if (block.closest('.code-block-container')) return; // Skip if it's the new container

                    const button = document.createElement('button');
                    button.className = 'copy-button attached';
                    button.textContent = 'Copy';
                    block.appendChild(button);
                    button.addEventListener('click', () => {
                        const code = block.querySelector('code')?.innerText || block.innerText;
                        navigator.clipboard.writeText(code).then(() => {
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    });
                });
            }
            
            function addMessage(text, sender, target = 'pdf_chat', imageB64 = null) {
                const history = (target === 'ai_chat') ? aiChatHistory : pdfChatHistory;
                const container = target.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;
                
                // Logic for the Thoughts bubble
                if (target.endsWith('_thoughts')) {
                    const bubble = document.createElement('div');
                    bubble.classList.add('thoughts-bubble', 'w-full', 'self-start', 'mr-auto');
                    
                    const details = document.createElement('details');
                    details.classList.add('w-full');
                    
                    const summary = document.createElement('summary');
                    summary.textContent = '...AI is thinking... (Click to view)';
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.classList.add('thoughts-content', 'pt-2', 'pb-1');
                    
                    details.appendChild(summary);
                    details.appendChild(contentDiv);
                    bubble.appendChild(details);
                    
                    container.appendChild(bubble);
                    container.scrollTop = container.scrollHeight;
                    
                    return { bubble: bubble, contentDiv: contentDiv, summary: summary };
                }
                
                // Standard Chat Bubbles
                const bubble = document.createElement('div');
                bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                
                if (sender === 'user') {
                    bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                } else {
                    bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                }
                
                const textNode = document.createElement('div');
                textNode.textContent = text; 
                bubble.appendChild(textNode);
                
                if (sender === 'user' && imageB64) {
                    const img = document.createElement('img');
                    img.src = `data:image/jpeg;base64,${imageB64}`;
                    bubble.appendChild(img);
                }
                
                container.appendChild(bubble);
                container.scrollTop = container.scrollHeight;
                
                if (sender === 'user' || (sender !== 'system' && text !== '' && !streamingState[target].active)) {
                    history.push({ sender, text: text, imageB64 });
                }
                
                return { bubble: bubble, contentDiv: textNode, summary: null };
            }

            function handleServerMessage(message) {
                const targetKey = message.target || 'pdf_chat';
                const mainTarget = targetKey.endsWith('_thoughts') ? targetKey.replace('_thoughts', '_chat') : targetKey;

                switch (message.type) {
                    case 'status':
                        addMessage(message.data, 'ai', mainTarget);
                        if (message.data.includes("Ready for questions")) {
                            setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                        }
                        break;
                        
                    case 'answer_chunk':
                        if (!streamingState[targetKey].active) {
                            // Initialize stream state
                            streamingState[targetKey].active = true;
                            streamingState[targetKey].ended = false;
                            streamingState[targetKey].textBuffer = ''; 
                            streamingState[targetKey].currentText = '';
                            streamingState[targetKey].isCode = false; // Reset code state

                            if (targetKey.endsWith('_thoughts')) {
                                const thoughtElements = addMessage('', 'ai', targetKey);
                                streamingState[targetKey].bubble = thoughtElements.bubble;
                                streamingState[targetKey].contentDiv = thoughtElements.contentDiv;
                                streamingState[targetKey].summary = thoughtElements.summary;
                                streamingState[mainTarget].active = true; 
                                setUIState('ai_thinking', 'AI is thinking...'); 
                            } else {
                                if (!streamingState[mainTarget.replace('_chat', '_thoughts')].active) {
                                    const answerElements = addMessage('', 'ai', targetKey);
                                    streamingState[targetKey].bubble = answerElements.bubble;
                                    streamingState[targetKey].contentDiv = answerElements.contentDiv;
                                }
                            }
                            
                            if (!renderInterval) { 
                                renderInterval = setInterval(() => renderCharacters(), RENDER_SPEED); 
                            }
                        }
                        
                        streamingState[targetKey].textBuffer += message.data;
                        break;
                        
                    case 'answer_end':
                        streamingState[targetKey].ended = true;
                        
                        if (targetKey.endsWith('_thoughts')) {
                             const state = streamingState[targetKey];
                             if (state.summary) {
                                state.summary.textContent = 'View Thinking Process (Finished)';
                             }
                        }
                        break;
                        
                    case 'error':
                        addMessage(`Error: ${message.data}`, 'ai', mainTarget);
                        finalizeStream(mainTarget, true); 
                        cleanupStreaming(mainTarget.replace('_chat', '_thoughts'));
                        break;
                        
                    case 'pong':
                        break;
                        
                    default:
                        console.warn("‚ö†Ô∏è Unknown message type:", message.type);
                }
            }
            
            function renderCharacters() { 
                const renderSpeed = fastMode ? 999999 : CHARS_PER_TICK; // Use max number for instant paste
                
                for (let key in streamingState) {
                    const state = streamingState[key];
                    
                    if (state.active) {
                        
                        // 1. Create Main Answer Bubble if Thoughts just finished
                        if (key.endsWith('_chat') && streamingState[key.replace('_chat', '_thoughts')].ended && !state.bubble) {
                            const answerElements = addMessage('', 'ai', key);
                            state.bubble = answerElements.bubble;
                            state.contentDiv = answerElements.contentDiv;
                        }

                        if (state.textBuffer.length > 0 || (state.ended && state.currentText.length > 0)) {
                            
                            const charsToRender = Math.min(state.textBuffer.length, renderSpeed);
                            const chunk = state.textBuffer.substring(0, charsToRender);
                            state.currentText += chunk;
                            state.textBuffer = state.textBuffer.substring(charsToRender);

                            if (state.contentDiv) {
                                
                                if (key.endsWith('_thoughts')) {
                                    state.contentDiv.innerHTML = marked.parse(state.currentText);
                                } else if (key.endsWith('_chat')) {
                                    
                                    // NEW CODE RENDERING LOGIC
                                    const text = state.currentText;
                                    const codeMatch = text.match(/```(\w+)?\n?([\s\S]*?)```/);

                                    if (codeMatch && !state.isCode) {
                                        // Code block found, switch to HTML rendering mode
                                        state.isCode = true;
                                    } else if (!codeMatch && state.isCode) {
                                         // If code block was previously active but now closed, reset state
                                         state.isCode = false;
                                    }
                                    
                                    if (state.isCode) {
                                        // While in code block mode, use marked.parse for real-time update
                                        // Then look for the code block and apply line numbering
                                        const tempHtml = marked.parse(text);
                                        state.contentDiv.innerHTML = tempHtml;
                                        
                                        const codeBlock = state.contentDiv.querySelector('pre');
                                        if (codeBlock) {
                                            const codeText = codeBlock.textContent;
                                            const finalCodeHtml = renderCodeBlock(codeText);
                                            // Replace the standard <pre> with the custom numbered one
                                            codeBlock.outerHTML = finalCodeHtml;
                                        }

                                    } else {
                                        // Standard text rendering
                                        state.contentDiv.textContent = text;
                                    }
                                }
                                
                                const container = key.startsWith('ai_') ? ui.chatContainerAI : ui.chatContainer;
                                container.scrollTop = container.scrollHeight;
                            }
                        }
                        
                        // 2. Finalization Check
                        if (state.ended && state.textBuffer.length === 0) {
                            
                            if (key.endsWith('_thoughts')) {
                                finalizeStream(key);
                            } else if (key.endsWith('_chat')) {
                                const thoughtKey = key.replace('_chat', '_thoughts');
                                if (!streamingState[thoughtKey].active) {
                                    finalizeStream(key);
                                }
                            }
                        }
                    }
                }
                
                // Final check to see if we can kill the interval
                let anyActive = Object.values(streamingState).some(s => s.active);
                if (!anyActive && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            }
            
            function cleanupStreaming(target) {
                const targets = [target];
                if (target.endsWith('_chat')) {
                    targets.push(target.replace('_chat', '_thoughts'));
                }
                
                targets.forEach(key => {
                    if (streamingState[key]) {
                        streamingState[key] = { 
                            active: false, 
                            bubble: null, 
                            contentDiv: null,
                            summary: null,
                            ended: false, 
                            textBuffer: '', 
                            currentText: '',
                            isCode: false // Reset code flag on cleanup
                        };
                    }
                });

                let anyActive = Object.values(streamingState).some(s => s.active);
                if (!anyActive && renderInterval) {
                    clearInterval(renderInterval);
                    renderInterval = null;
                }
            }
            
            function finalizeStream(target, isError = false) {
                const state = streamingState[target];
                if (!state.active) {
                    return;
                }

                if (state.textBuffer.length > 0) {
                    state.currentText += state.textBuffer;
                    state.textBuffer = '';
                }
                
                const text = state.currentText.trim(); 
                
                if (state.contentDiv) {
                    // Final conversion for both normal text and code (the custom renderer handles code)
                    state.contentDiv.innerHTML = marked.parse(text);
                    
                    // Final pass to apply custom code formatting (must happen BEFORE addCopyButtonsTo)
                    if (target.endsWith('_chat')) {
                        state.contentDiv.querySelectorAll('pre').forEach(pre => {
                            if (pre.querySelector('code')) {
                                const codeText = pre.textContent;
                                pre.outerHTML = renderCodeBlock(codeText);
                            }
                        });
                    }
                    
                    addCopyButtonsTo(state.contentDiv);
                    
                    if (target.endsWith('_thoughts') && state.summary) {
                         state.summary.textContent = 'View Thinking Process (Finished)';
                    }
                    
                    if (target.endsWith('_chat') && !isError && text.length > 0) {
                        const history = target === 'ai_chat' ? aiChatHistory : pdfChatHistory;
                        history.push({ 
                            sender: 'ai', 
                            text: text, 
                            imageB64: null 
                        });
                        autosaveChat();
                    }
                }
                
                cleanupStreaming(target);

                if (target.endsWith('_chat')) {
                    if (target === 'pdf_chat' && currentPDFName) {
                        setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                    } else {
                        setUIState('worker_ready', 'AI worker connected.');
                    }
                }
            } 
            
            // --- NEW: Fast Mode Toggle Logic ---
            function toggleFastMode(button) {
                fastMode = !fastMode;
                
                [ui.fastModeButtonAi, ui.fastModeButtonPdf].forEach(btn => {
                    if (fastMode) {
                        btn.classList.add('fast-active');
                        btn.textContent = '‚ö° FAST MODE ACTIVE';
                    } else {
                        btn.classList.remove('fast-active');
                        btn.textContent = '‚ö° Fast Paste';
                    }
                });

                // If fast mode is turned ON AND a stream is active, immediately trigger a render cycle to flush the buffer.
                if (fastMode && Object.values(streamingState).some(s => s.active) && renderInterval) {
                    // Temporarily run the loop quickly to flush the buffer
                    clearInterval(renderInterval);
                    renderInterval = setInterval(() => renderCharacters(), 1); // Max speed for one tick
                } else if (!fastMode && Object.values(streamingState).some(s => s.active)) {
                    // Restore original speed if a stream is active
                    clearInterval(renderInterval);
                    renderInterval = setInterval(() => renderCharacters(), RENDER_SPEED);
                }
            }

            ui.fastModeButtonPdf.addEventListener('click', () => toggleFastMode(ui.fastModeButtonPdf));
            ui.fastModeButtonAi.addEventListener('click', () => toggleFastMode(ui.fastModeButtonAi));
            // --- END NEW LOGIC ---
            
            // --- STANDARD FUNCTIONS (loadSavedChats, loadChat, startNewChat, uploadPDF, sendMessage, etc.) ---
            
            function renderHistory(history, target = 'pdf_chat') {
                const container = (target === 'ai_chat') ? ui.chatContainerAI : ui.chatContainer;
                container.innerHTML = '';
                history.forEach(msg => {
                    const bubble = document.createElement('div');
                    bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                    if (msg.sender === 'user') {
                        bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                        const textNode = document.createElement('div');
                        textNode.textContent = msg.text;
                        bubble.appendChild(textNode);
                        if (msg.imageB64) {
                            const img = document.createElement('img');
                            img.src = `data:image/jpeg;base64,${msg.imageB64}`;
                            bubble.appendChild(img);
                        }
                    } else {
                        bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                        const textNode = document.createElement('div');
                        let finalHtml = marked.parse(msg.text);
                        
                        // Replace code blocks in history with custom numbered blocks
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = finalHtml;
                        tempDiv.querySelectorAll('pre').forEach(pre => {
                            if (pre.querySelector('code')) {
                                const codeText = pre.textContent;
                                pre.outerHTML = renderCodeBlock(codeText);
                            }
                        });
                        finalHtml = tempDiv.innerHTML;
                        
                        textNode.innerHTML = finalHtml;
                        bubble.appendChild(textNode);
                        addCopyButtonsTo(bubble);
                    }
                    container.appendChild(bubble);
                });
                container.scrollTop = container.scrollHeight;
            }

            function autosaveChat() { 
                const historyToSave = (activeTab === 'ai_chat') ? aiChatHistory : pdfChatHistory; 
                if (historyToSave.length === 0) return; 
                
                let chatId = (activeTab === 'ai_chat') ? 
                sessionStorage.getItem('currentAIChatId') : 
                sessionStorage.getItem('currentPdfChatId'); 
                const firstUserMessage = historyToSave.find(m => m.sender === 'user')?.text || 'New Chat'; 

                const chatName = (activeTab === 'pdf_chat' && 
                currentPDFName) ? `${currentPDFName.replace('.pdf', '')}` : 
                firstUserMessage.substring(0, 30); 
                
                if (!chatId) { 
                    chatId = `chat_${Date.now()}`; 
                    if (activeTab === 'ai_chat') sessionStorage.setItem('currentAIChatId', chatId); 
                    else sessionStorage.setItem('currentPdfChatId', chatId); 
                } 
                
                const chatData = { 
                    id: chatId, 
                    name: chatName, 
                    type: activeTab, 
                    timestamp: new Date().toISOString(), 
                    history: historyToSave, 
                    pdfName: (activeTab === 'pdf_chat') ? currentPDFName : null 
                }; 
                
                localStorage.setItem(chatId, JSON.stringify(chatData)); 
            } 
            
            function loadSavedChats() { 
                ui.sidebarTitle.textContent = activeTab === 'pdf_chat' ? "Saved PDF Chats" : "Saved AI Chats"; 
                ui.savedChatsList.innerHTML = ''; 
                const chats = []; 
                
                for (let i = 0; i < localStorage.length; i++) { 
                    const key = localStorage.key(i); 
                    if (key.startsWith('chat_')) { 
                        const chat = JSON.parse(localStorage.getItem(key)); 
                        if (chat.type === activeTab) chats.push(chat); 
                    } 
                } 
                
                chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); 
                
                if (chats.length === 0) { 
                    ui.savedChatsList.innerHTML = '<p class="text-slate-400">No saved chats.</p>'; 
                } else { 
                    chats.forEach(chat => { 
                        const item = document.createElement('div'); 

                        item.className = 'p-2 bg-slate-700 rounded-md cursor-pointer hover:bg-slate-600 truncate flex justify-between items-center'; 
                        item.textContent = chat.name; 
                        item.onclick = () => loadChat(chat.id); 
                        
                        const deleteBtn = document.createElement('button'); 
                        deleteBtn.className = 'text-red-400 hover:text-red-300 ml-2'; 
                        deleteBtn.innerHTML = '&times;'; 
                        deleteBtn.onclick = (e) => { 
                            e.stopPropagation(); 
                            if (confirm(`Delete "${chat.name}"?`)) { 
                                localStorage.removeItem(chat.id); 
                                loadSavedChats(); 
                            } 
                        }; 
                        item.appendChild(deleteBtn); 
                        ui.savedChatsList.appendChild(item); 
                    }); 
                } 
            } 

            function loadChat(chatId) { 
                const chatData = JSON.parse(localStorage.getItem(chatId)); 
                if (!chatData) return; 
                
                if (chatData.type === 'pdf_chat') { 
                    pdfChatHistory = chatData.history; 
                    currentPDFName = chatData.pdfName; 
                    sessionStorage.setItem('currentPdfChatId', chatId); 
                    renderHistory(pdfChatHistory, 'pdf_chat'); 
                    ui.pdfTitle.textContent = currentPDFName || 'PDF Preview'; 
                    ui.pdfViewer.src = ''; 
                    setUIState('worker_ready', `Loaded chat for '${currentPDFName}'. Re-upload file to continue.`); 
                    addMessage(`Please re-upload "${currentPDFName}" to continue this conversation.`, 'system', 'pdf_chat'); 
                } else { 
                    aiChatHistory = chatData.history; 
                    sessionStorage.setItem('currentAIChatId', chatId); 
                    renderHistory(aiChatHistory, 'ai_chat'); 
                    setUIState('worker_ready', 'AI worker connected.'); 
                } 
                ui.sidebar.classList.add('-translate-x-full'); 
            } 

            function startNewChat() { 
                if (activeTab === 'pdf_chat') { 
                    pdfChatHistory = []; 
                    currentPDFName = null; 
                    sessionStorage.removeItem('currentPdfChatId'); 
                    ui.chatContainer.innerHTML = ''; 
                    ui.pdfTitle.textContent = 'PDF Preview'; 
                    ui.pdfViewer.src = ''; 
                } else { 
                    aiChatHistory = []; 
                    sessionStorage.removeItem('currentAIChatId'); 
                    ui.chatContainerAI.innerHTML = ''; 
                } 
                setUIState('worker_ready', 'AI worker connected.'); 
            } 

            async function uploadPDF() { 
                const file = ui.pdfUploadInput.files[0]; 
                if (!file) return; 
                
                startNewChat(); 
                currentPDFName = file.name; 
                ui.pdfTitle.textContent = currentPDFName; 
                ui.pdfViewer.src = URL.createObjectURL(file); 
                setUIState('processing', `Processing '${file.name}'...`); 
                addMessage(`Uploading and sending to worker...`, 'ai', 'pdf_chat'); 
                
                const formData = new FormData(); 
                formData.append('file', file); 
                
                try { 
                    const response = await fetch(`/upload/${userId}`, { method: 'POST', body: formData }); 
                    if (!response.ok) { 
                        const errorData = await response.json(); 
                        throw new Error(errorData.detail || 'Failed to start PDF processing.'); 
                    } 
                } catch (error) { 
                    addMessage(`Error: ${error.message}`, 'ai', 'pdf_chat'); 
                    setUIState('worker_ready', 'Upload failed.'); 
                } 
            } 

            function sendMessage() { 
                const question = ui.messageInput.value.trim(); 
                if (!question || !socket || socket.readyState !== WebSocket.OPEN) return; 
                
                if (streamingState.pdf_chat.active || streamingState.pdf_thoughts.active) { 
                    return; 
                } 
                
                addMessage(question, 'user', 'pdf_chat'); 
                
                const historyForAI = pdfChatHistory.slice(0, -1); 
                socket.send(JSON.stringify({ 
                    type: 'ask', 
                    target: 'pdf_chat',
                    data: { question: question, history: historyForAI } 
                })); 
                
                ui.messageInput.value = ''; 
                setUIState('ai_thinking', 'AI is thinking...'); 
            } 
            
            function sendMessageAIChat() { 
                const question = ui.messageInputAI.value.trim(); 
                if ((!question && !uploadedImageB64) || !socket || socket.readyState !== WebSocket.OPEN) return; 
                
                if (streamingState.ai_chat.active || streamingState.ai_thoughts.active) { 
                    return; 
                } 
                
                addMessage(question, 'user', 'ai_chat', uploadedImageB64); 
                
                const historyForAI = aiChatHistory.slice(0, -1); 
                const payload = { 
                    question: question, 
                    history: historyForAI, 
                    image_b64: uploadedImageB64 
                }; 
                const taskType = uploadedImageB64 ? 'general_chat_with_image' : 'general_chat'; 
                
                socket.send(JSON.stringify({ 
                    type: taskType, 
                    target: 'ai_chat',
                    data: payload 
                })); 
                
                ui.messageInputAI.value = ''; 
                ui.imagePreviewContainerAI.style.display = 'none'; 
                uploadedImageB64 = null; 
                setUIState('ai_thinking', 'AI is thinking...'); 
            } 

            function handleImageFile(file) { 
                if (!file || !file.type.startsWith('image/')) return; 
                
                const reader = new FileReader(); 
                reader.onload = (event) => { 
                    uploadedImageB64 = event.target.result.split(',')[1]; 
                    ui.imagePreviewAI.src = event.target.result; 
                    ui.imagePreviewContainerAI.style.display = 'block'; 
                }; 
                reader.readAsDataURL(file); 
            } 
            
            // --- Event Listeners for UI ---
            ui.tabChatPDF.addEventListener('click', () => { 
                activeTab = 'pdf_chat'; 
                ui.viewChatPDF.style.display = 'grid'; 
                ui.viewAIChat.style.display = 'none'; 
                ui.tabChatPDF.classList.add('active'); 
                ui.tabAIChat.classList.remove('active'); 
            }); 
            
            ui.tabAIChat.addEventListener('click', () => { 
                activeTab = 'ai_chat'; 
                ui.viewChatPDF.style.display = 'none'; 
                ui.viewAIChat.style.display = 'flex'; 
                ui.tabChatPDF.classList.remove('active'); 
                ui.tabAIChat.classList.add('active'); 
            }); 
            
            ui.openSidebarButton.addEventListener('click', () => { 
                loadSavedChats(); 
                ui.sidebar.classList.remove('-translate-x-full'); 
            }); 
            
            ui.closeSidebarButton.addEventListener('click', () => 
                ui.sidebar.classList.add('-translate-x-full') 
            ); 
            
            ui.newChatButton.addEventListener('click', () => { 
                startNewChat(); 
                ui.sidebar.classList.add('-translate-x-full'); 
            }); 
            
            ui.pdfUploadInput.addEventListener('change', uploadPDF); 
            ui.sendButton.addEventListener('click', sendMessage); 
            ui.messageInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessage(); 
                } 
            }); 
            
            ui.sendButtonAI.addEventListener('click', sendMessageAIChat); 
            ui.messageInputAI.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessageAIChat(); 
                } 
            }); 
            
            ui.imageUploadAI.addEventListener('change', (e) => handleImageFile(e.target.files[0])); 
            
            ui.removeImageButtonAI.addEventListener('click', () => { 
                uploadedImageB64 = null; 
                ui.imagePreviewContainerAI.style.display = 'none'; 
                ui.imageUploadAI.value = ''; 
            }); 
            
            ui.messageInputAI.addEventListener('paste', (e) => { 
                const items = (e.clipboardData || window.clipboardData).items; 
                for (const item of items) { 
                    if (item.kind === 'file' && item.type.startsWith('image/')) { 
                        e.preventDefault(); 
                        const file = item.getAsFile(); 
                        handleImageFile(file); 
                        return; 
                    } 
                } 
            }); 

            // Initialize 
            checkWorkerStatus(); 
            ui.tabChatPDF.click(); 
        }); 
    </script>
</body>
</html>
