<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Toolkit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .chat-bubble { max-width: 90%; word-wrap: break-word; white-space: pre-wrap; }
        .user-bubble { background-color: #2563eb; color: white; }
        .ai-bubble { background-color: #334155; color: #f1f5f9; }
        #chat-sidebar { transition: transform 0.3s ease-in-out; }
        .tab-button.active { border-color: #4f46e5; color: #4f46e5; }
        
        #chat-container::-webkit-scrollbar, #chat-container-ai::-webkit-scrollbar, #saved-chats-list::-webkit-scrollbar { width: 8px; }
        #chat-container::-webkit-scrollbar-track, #chat-container-ai::-webkit-scrollbar-track, #saved-chats-list::-webkit-scrollbar-track { background: #1e293b; }
        #chat-container::-webkit-scrollbar-thumb, #chat-container-ai::-webkit-scrollbar-thumb, #saved-chats-list::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        
        .ai-bubble pre { background-color: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; position: relative; }
        .ai-bubble code { font-family: 'Courier New', Courier, monospace; }
        .user-bubble img { max-width: 150px; border-radius: 0.5rem; margin-top: 0.5rem; }
        .copy-button { position: absolute; top: 0.5rem; right: 0.5rem; background-color: #475569; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.8rem; opacity: 0; transition: opacity 0.2s; }
        pre:hover .copy-button { opacity: 1; }
        .ai-bubble table { width: 100%; margin-top: 1em; margin-bottom: 1em; border-collapse: collapse; border: 1px solid #475569; }
        .ai-bubble th, .ai-bubble td { border: 1px solid #475569; padding: 0.5rem 0.75rem; text-align: left; }
        .ai-bubble th { background-color: #1e293b; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div class="flex h-full">
        <aside id="chat-sidebar" class="w-64 bg-slate-800 text-white flex flex-col p-4 transform -translate-x-full fixed h-full z-20">
            <div class="flex justify-between items-center mb-4 border-b border-slate-600 pb-2">
                <h2 id="sidebar-title" class="text-xl font-bold">Saved Chats</h2>
                <button id="close-sidebar-button" class="text-slate-400 hover:text-white text-2xl">&times;</button>
            </div>
            <button id="new-chat-button" class="w-full text-left p-2 mb-2 bg-indigo-500 rounded-md hover:bg-indigo-600">Ôºã New Chat</button>
            <div id="saved-chats-list" class="flex-1 overflow-y-auto space-y-2"></div>
        </aside>

        <div class="flex-1 flex flex-col h-full">
             <header class="bg-white shadow-md p-4 flex items-center justify-between z-10">
                <div class="flex items-center space-x-4">
                    <button id="open-sidebar-button" class="p-2 rounded-md hover:bg-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                    </button>
                    <div>
                        <h1 class="text-2xl font-bold text-gray-800">AI Toolkit</h1>
                        <p id="status" class="text-sm text-gray-500">Status: Connecting to server...</p>
                    </div>
                </div>
                <div>
                    <button id="tab-chatpdf" class="tab-button py-2 px-4 text-gray-500 font-semibold border-b-2">ChatPDF</button>
                    <button id="tab-ai-chat" class="tab-button py-2 px-4 text-gray-500 font-semibold border-b-2">AI Chat</button>
                </div>
            </header>

            <div id="view-chatpdf" class="flex-1 grid grid-cols-2 gap-4 p-4 overflow-hidden">
                <section class="bg-white rounded-lg shadow-md flex flex-col h-full">
                    <div class="p-2 border-b bg-gray-50"><h2 id="pdf-title" class="text-lg font-bold text-gray-700 truncate">PDF Preview</h2></div>
                    <div class="flex-1 p-2"><embed id="pdf-viewer" src="" type="application/pdf" width="100%" height="100%"/></div>
                </section>
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">
                            <label for="pdf-upload" id="upload-label" class="cursor-not-allowed bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">üìÅ Upload</label>
                            <input id="pdf-upload" type="file" class="hidden" accept=".pdf" disabled>
                            <input type="text" id="message-input" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2" placeholder="Please connect to worker..." disabled>
                            <button id="send-button" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>

            <div id="view-ai-chat" style="display: none;" class="flex-1 flex flex-col p-4 overflow-hidden">
                <section class="bg-slate-800 rounded-lg shadow-md flex flex-col h-full overflow-hidden">
                    <main id="chat-container-ai" class="flex-1 p-4 space-y-4 overflow-y-auto"></main>
                    <div id="image-preview-container-ai" class="p-4 pt-0" style="display: none;">
                        <div class="relative w-24 h-24">
                            <img id="image-preview-ai" class="w-full h-full object-cover rounded-md">
                            <button id="remove-image-button-ai" class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center -mt-2 -mr-2">&times;</button>
                        </div>
                    </div>
                    <footer class="bg-slate-900/50 p-4 border-t border-slate-700">
                        <div class="flex items-center space-x-4">
                            <label for="image-upload-ai" class="cursor-pointer text-slate-400 hover:text-white p-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                            </label>
                            <input id="image-upload-ai" type="file" class="hidden" accept="image/jpeg,image/png">
                            <input type="text" id="message-input-ai" class="flex-1 bg-slate-700 border border-slate-600 text-white rounded-lg p-2" placeholder="Please connect to worker..." disabled>
                            <button id="send-button-ai" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg" disabled>Send</button>
                        </div>
                    </footer>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ui = {
                status: document.getElementById('status'),
                sidebar: document.getElementById('chat-sidebar'),
                sidebarTitle: document.getElementById('sidebar-title'),
                openSidebarButton: document.getElementById('open-sidebar-button'),
                closeSidebarButton: document.getElementById('close-sidebar-button'),
                newChatButton: document.getElementById('new-chat-button'),
                savedChatsList: document.getElementById('saved-chats-list'),
                
                tabChatPDF: document.getElementById('tab-chatpdf'),
                tabAIChat: document.getElementById('tab-ai-chat'),
                viewChatPDF: document.getElementById('view-chatpdf'),
                viewAIChat: document.getElementById('view-ai-chat'),

                chatContainer: document.getElementById('chat-container'),
                messageInput: document.getElementById('message-input'),
                sendButton: document.getElementById('send-button'),
                pdfUploadInput: document.getElementById('pdf-upload'),
                uploadLabel: document.getElementById('upload-label'),
                pdfViewer: document.getElementById('pdf-viewer'),
                pdfTitle: document.getElementById('pdf-title'),

                chatContainerAI: document.getElementById('chat-container-ai'),
                messageInputAI: document.getElementById('message-input-ai'),
                sendButtonAI: document.getElementById('send-button-ai'),
                imageUploadAI: document.getElementById('image-upload-ai'),
                imagePreviewContainerAI: document.getElementById('image-preview-container-ai'),
                imagePreviewAI: document.getElementById('image-preview-ai'),
                removeImageButtonAI: document.getElementById('remove-image-button-ai'),
            };
            
            let userId = localStorage.getItem('ai_toolkit_user_id') || `user_${Math.random().toString(36).substr(2, 9)}`;
            localStorage.setItem('ai_toolkit_user_id', userId);
            
            let pdfChatHistory = [];
            let aiChatHistory = [];
            let currentPDFName = null;
            let activeTab = 'pdf_chat';
            let uploadedImageB64 = null;

            // FIXED: Properly declare streaming bubble variables
            let pdfStreamingBubble = null;
            let aiChatStreamingBubble = null;
            
            let socket, statusInterval, pingInterval;
            let characterQueue = [];
            let renderInterval = null;

            function setUIState(state, message = "") {
                ui.status.textContent = `Status: ${message}`;
                const isChatReady = state === 'ready_to_chat';
                const isWorkerReady = state === 'worker_ready' || isChatReady;
                
                ui.pdfUploadInput.disabled = !isWorkerReady;
                ui.uploadLabel.classList.toggle('cursor-not-allowed', !isWorkerReady);
                ui.uploadLabel.classList.toggle('cursor-pointer', isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-gray-500', !isWorkerReady);
                ui.uploadLabel.classList.toggle('bg-blue-500', isWorkerReady);
                ui.uploadLabel.classList.toggle('hover:bg-blue-600', isWorkerReady);
                
                ui.messageInput.disabled = !isChatReady;
                ui.sendButton.disabled = !isChatReady;
                ui.messageInputAI.disabled = !isWorkerReady;
                ui.sendButtonAI.disabled = !isWorkerReady;

                if (isChatReady) {
                    ui.messageInput.placeholder = "Ask a question about the PDF...";
                    ui.sendButton.classList.remove('bg-gray-500'); 
                    ui.sendButton.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInput.placeholder = message;
                    ui.sendButton.classList.add('bg-gray-500'); 
                    ui.sendButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                }

                if (isWorkerReady) {
                    ui.messageInputAI.placeholder = "Send a message, or paste an image...";
                    ui.sendButtonAI.classList.remove('bg-gray-500'); 
                    ui.sendButtonAI.classList.add('bg-green-500', 'hover:bg-green-600');
                } else {
                    ui.messageInputAI.placeholder = message;
                    ui.sendButtonAI.classList.add('bg-gray-500'); 
                    ui.sendButtonAI.classList.remove('bg-green-500', 'hover:bg-green-600');
                }
            }

            async function checkWorkerStatus() {
                try {
                    const response = await fetch(`/status`);
                    if (!response.ok) throw new Error("Server not reachable");
                    const data = await response.json();
                    if (data.worker_connected) {
                        setUIState('worker_ready', 'AI worker connected.');
                        clearInterval(statusInterval);
                        connectWebSocket();
                    } else {
                        setUIState('waiting_for_worker', 'Waiting for local AI worker...');
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                    setUIState('error', 'Could not connect to server.');
                }
            }

            function connectWebSocket() {
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws/web/${userId}`;
                console.log('Connecting to WebSocket:', wsUrl);
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log("‚úÖ WebSocket connected successfully");
                    if (pingInterval) clearInterval(pingInterval);
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 20000);
                };

                socket.onmessage = (event) => {
                    console.log("üì® Message received:", event.data);
                    try {
                        const message = JSON.parse(event.data);
                        handleServerMessage(message);
                    } catch (error) {
                        console.error("‚ùå Failed to handle message:", error, event.data);
                    }
                };
                
                socket.onclose = (event) => {
                    console.log("üîå WebSocket disconnected. Code:", event.code, "Reason:", event.reason);
                    clearInterval(pingInterval);
                    if (renderInterval) clearInterval(renderInterval);
                    renderInterval = null;
                    characterQueue = [];
                    pdfStreamingBubble = null;
                    aiChatStreamingBubble = null;
                    
                    setUIState('disconnected', 'Disconnected. Trying to reconnect...');
                    if (statusInterval) clearInterval(statusInterval);
                    statusInterval = setInterval(checkWorkerStatus, 3000);
                };
                
                socket.onerror = (error) => {
                    console.error("‚ùå WebSocket Error:", error);
                };
            }

            function addCopyButtonsTo(containerElement) {
                containerElement.querySelectorAll('pre').forEach(block => {
                    if (block.querySelector('.copy-button')) return;
                    const button = document.createElement('button');
                    button.className = 'copy-button';
                    button.textContent = 'Copy';
                    block.appendChild(button);
                    button.addEventListener('click', () => {
                        const code = block.querySelector('code')?.innerText || block.innerText;
                        navigator.clipboard.writeText(code).then(() => {
                            button.textContent = 'Copied!';
                            setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                        });
                    });
                });
            }

            function handleServerMessage(message) {
                console.log("üîß Handling message type:", message.type, "Target:", message.target);
                
                // FIXED: Properly determine which bubble and container to use
                let targetBubble, targetContainer, targetHistory, stateToSet, statusMsg;
                const isAIChat = message.target === 'ai_chat';
                
                if (isAIChat) {
                    targetBubble = aiChatStreamingBubble;
                    targetContainer = ui.chatContainerAI;
                    targetHistory = aiChatHistory;
                    stateToSet = 'worker_ready';
                    statusMsg = 'AI worker connected.';
                } else {
                    targetBubble = pdfStreamingBubble;
                    targetContainer = ui.chatContainer;
                    targetHistory = pdfChatHistory;
                    stateToSet = 'ready_to_chat';
                    statusMsg = `Ready: ${currentPDFName}`;
                }

                switch (message.type) {
                    case 'status':
                        console.log("üìä Status update:", message.data);
                        addMessage(message.data, 'ai', 'pdf_chat');
                        if (message.data.includes("Ready for questions")) {
                            setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                        }
                        break;
                        
                    case 'answer_chunk':
                        console.log("üìù Answer chunk received, length:", message.data.length);
                        characterQueue.push(...message.data.split(''));
                        
                        // FIXED: Create bubble if it doesn't exist and properly track it
                        if (!targetBubble) {
                            console.log("üÜï Creating new streaming bubble for", message.target);
                            targetBubble = addMessage('', 'ai', message.target || 'pdf_chat');
                            if (isAIChat) {
                                aiChatStreamingBubble = targetBubble;
                            } else {
                                pdfStreamingBubble = targetBubble;
                            }
                        }
                        
                        // FIXED: Start render interval if not already running
                        if (!renderInterval) {
                            console.log("‚ñ∂Ô∏è Starting render interval");
                            renderInterval = setInterval(() => renderNextChunk(message.target || 'pdf_chat'), 15);
                        }
                        break;
                        
                    case 'answer_end':
                        console.log("‚úÖ Answer complete");
                        // The render loop will handle cleanup when queue is empty
                        break;
                        
                    case 'error':
                        console.error("‚ùå Server error:", message.data);
                        const errorTarget = pdfStreamingBubble ? 'pdf_chat' : (aiChatStreamingBubble ? 'ai_chat' : activeTab);
                        addMessage(`Error: ${message.data}`, 'ai', errorTarget);
                        
                        // FIXED: Clean up streaming state on error
                        if (renderInterval) {
                            clearInterval(renderInterval);
                            renderInterval = null;
                        }
                        characterQueue = [];
                        pdfStreamingBubble = null;
                        aiChatStreamingBubble = null;
                        
                        setUIState('worker_ready', 'Error. Please try again.');
                        break;
                        
                    case 'pong':
                        // Ignore pong responses
                        break;
                        
                    default:
                        console.warn("‚ö†Ô∏è Unknown message type:", message.type);
                }
            }
            
            function renderNextChunk(target) {
                const isAIChat = target === 'ai_chat';
                const history = isAIChat ? aiChatHistory : pdfChatHistory;
                const container = isAIChat ? ui.chatContainerAI : ui.chatContainer;
                const streamingBubble = isAIChat ? aiChatStreamingBubble : pdfStreamingBubble;
                
                // FIXED: Check if queue is empty and clean up
                if (characterQueue.length === 0) {
                    console.log("üèÅ Render complete, cleaning up");
                    clearInterval(renderInterval);
                    renderInterval = null;
                    
                    if (streamingBubble) {
                        // Convert markdown to HTML
                        const finalHTML = marked.parse(streamingBubble.textContent);
                        streamingBubble.innerHTML = finalHTML;
                        addCopyButtonsTo(streamingBubble);
                        
                        // Update history
                        const lastMessage = history[history.length - 1];
                        if (lastMessage && lastMessage.sender === 'ai') {
                            lastMessage.text = streamingBubble.textContent;
                        }
                        
                        autosaveChat();
                    }
                    
                    // FIXED: Clear the appropriate streaming bubble
                    if (isAIChat) {
                        aiChatStreamingBubble = null;
                        setUIState('worker_ready', 'AI worker connected.');
                    } else {
                        pdfStreamingBubble = null;
                        setUIState('ready_to_chat', `Ready: ${currentPDFName}`);
                    }
                    
                    return;
                }
                
                // Render a batch of characters
                const batchSize = Math.max(1, Math.floor(characterQueue.length / 4));
                const charsToRender = characterQueue.splice(0, batchSize).join('');
                
                if (streamingBubble) {
                    streamingBubble.textContent += charsToRender;
                    container.scrollTop = container.scrollHeight;
                }
            }

            function addMessage(text, sender, target = 'pdf_chat', imageB64 = null) {
                const history = (target === 'ai_chat') ? aiChatHistory : pdfChatHistory;
                const container = (target === 'ai_chat') ? ui.chatContainerAI : ui.chatContainer;
                
                const bubble = document.createElement('div');
                bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                
                if (sender === 'user') {
                    bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                } else {
                    bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                }
                
                const textNode = document.createElement('div');
                textNode.textContent = text;
                bubble.appendChild(textNode);
                
                if (sender === 'user' && imageB64) {
                    const img = document.createElement('img');
                    img.src = `data:image/jpeg;base64,${imageB64}`;
                    bubble.appendChild(img);
                }
                
                container.appendChild(bubble);
                container.scrollTop = container.scrollHeight;
                
                // Only add to history if it's a user message or a non-empty AI message
                // Don't add streaming AI messages to history yet (they'll be added when complete)
                if (sender === 'user') {
                    history.push({ sender, text, imageB64});
                } else if (sender !== 'system' && text !== '') {
                    // Only add non-streaming AI messages (like status messages)
                    history.push({ sender, text, imageB64 });
                }
                
                return bubble;
            }

            function renderHistory(history, target = 'pdf_chat') {
                const container = (target === 'ai_chat') ? ui.chatContainerAI : ui.chatContainer;
                container.innerHTML = '';
                history.forEach(msg => {
                    const bubble = document.createElement('div');
                    bubble.classList.add('chat-bubble', 'p-3', 'rounded-lg', 'w-fit');
                    if (msg.sender === 'user') {
                        bubble.classList.add('user-bubble', 'self-end', 'ml-auto');
                        const textNode = document.createElement('div');
                        textNode.textContent = msg.text;
                        bubble.appendChild(textNode);
                        if (msg.imageB64) {
                            const img = document.createElement('img');
                            img.src = `data:image/jpeg;base64,${msg.imageB64}`;
                            bubble.appendChild(img);
                        }
                    } else {
                        bubble.classList.add('ai-bubble', 'self-start', 'mr-auto');
                        bubble.innerHTML = marked.parse(msg.text);
                        addCopyButtonsTo(bubble);
                    }
                    container.appendChild(bubble);
                });
                container.scrollTop = container.scrollHeight;
            }

            function autosaveChat() {
                const historyToSave = (activeTab === 'ai_chat') ? aiChatHistory : pdfChatHistory;
                if (historyToSave.length === 0) return;
                
                let chatId = (activeTab === 'ai_chat') ? sessionStorage.getItem('currentAIChatId') : sessionStorage.getItem('currentPdfChatId');
                const firstUserMessage = historyToSave.find(m => m.sender === 'user')?.text || 'New Chat';
                const chatName = (activeTab === 'pdf_chat' && currentPDFName) ? `${currentPDFName.replace('.pdf', '')}` : firstUserMessage.substring(0, 30);
                
                if (!chatId) {
                    chatId = `chat_${Date.now()}`;
                    if (activeTab === 'ai_chat') sessionStorage.setItem('currentAIChatId', chatId);
                    else sessionStorage.setItem('currentPdfChatId', chatId);
                }
                
                const chatData = { 
                    id: chatId, 
                    name: chatName, 
                    type: activeTab, 
                    timestamp: new Date().toISOString(), 
                    history: historyToSave, 
                    pdfName: (activeTab === 'pdf_chat') ? currentPDFName : null 
                };
                
                localStorage.setItem(chatId, JSON.stringify(chatData));
                console.log(`üíæ Autosaved chat: ${chatName}`);
            }
            
            function loadSavedChats() {
                ui.sidebarTitle.textContent = activeTab === 'pdf_chat' ? "Saved PDF Chats" : "Saved AI Chats";
                ui.savedChatsList.innerHTML = '';
                const chats = [];
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('chat_')) {
                        const chat = JSON.parse(localStorage.getItem(key));
                        if (chat.type === activeTab) chats.push(chat);
                    }
                }
                
                chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                if (chats.length === 0) {
                    ui.savedChatsList.innerHTML = '<p class="text-slate-400">No saved chats.</p>';
                } else {
                    chats.forEach(chat => {
                        const item = document.createElement('div');
                        item.className = 'p-2 bg-slate-700 rounded-md cursor-pointer hover:bg-slate-600 truncate flex justify-between items-center';
                        item.textContent = chat.name;
                        item.onclick = () => loadChat(chat.id);
                        
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'text-red-400 hover:text-red-300 ml-2';
                        deleteBtn.innerHTML = '&times;';
                        deleteBtn.onclick = (e) => { 
                            e.stopPropagation(); 
                            if (confirm(`Delete "${chat.name}"?`)) { 
                                localStorage.removeItem(chat.id); 
                                loadSavedChats(); 
                            } 
                        };
                        item.appendChild(deleteBtn);
                        ui.savedChatsList.appendChild(item);
                    });
                }
            }

            function loadChat(chatId) {
                const chatData = JSON.parse(localStorage.getItem(chatId));
                if (!chatData) return;
                
                if (chatData.type === 'pdf_chat') {
                    pdfChatHistory = chatData.history;
                    currentPDFName = chatData.pdfName;
                    sessionStorage.setItem('currentPdfChatId', chatId);
                    renderHistory(pdfChatHistory, 'pdf_chat');
                    ui.pdfTitle.textContent = currentPDFName || 'PDF Preview';
                    ui.pdfViewer.src = '';
                    setUIState('worker_ready', `Loaded chat for '${currentPDFName}'. Re-upload file to continue.`);
                    addMessage(`Please re-upload "${currentPDFName}" to continue this conversation.`, 'system', 'pdf_chat');
                } else {
                    aiChatHistory = chatData.history;
                    sessionStorage.setItem('currentAIChatId', chatId);
                    renderHistory(aiChatHistory, 'ai_chat');
                    setUIState('worker_ready', 'AI worker connected.');
                }
                ui.sidebar.classList.add('-translate-x-full');
            }

            function startNewChat() {
                if (activeTab === 'pdf_chat') {
                    pdfChatHistory = []; 
                    currentPDFName = null;
                    sessionStorage.removeItem('currentPdfChatId');
                    ui.chatContainer.innerHTML = ''; 
                    ui.pdfTitle.textContent = 'PDF Preview'; 
                    ui.pdfViewer.src = '';
                } else {
                    aiChatHistory = [];
                    sessionStorage.removeItem('currentAIChatId');
                    ui.chatContainerAI.innerHTML = '';
                }
                setUIState('worker_ready', 'AI worker connected.');
            }

            async function uploadPDF() {
                const file = ui.pdfUploadInput.files[0];
                if (!file) return;
                
                startNewChat();
                currentPDFName = file.name;
                ui.pdfTitle.textContent = currentPDFName;
                ui.pdfViewer.src = URL.createObjectURL(file);
                setUIState('processing', `Processing '${file.name}'...`);
                addMessage(`Uploading and sending to worker...`, 'ai', 'pdf_chat');
                
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    console.log("üì§ Uploading PDF to server...");
                    const response = await fetch(`/upload/${userId}`, { method: 'POST', body: formData });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Failed to start PDF processing.');
                    }
                    console.log("‚úÖ PDF uploaded successfully");
                } catch (error) {
                    console.error("‚ùå Upload error:", error);
                    addMessage(`Error: ${error.message}`, 'ai', 'pdf_chat');
                    setUIState('worker_ready', 'Upload failed.');
                }
            }

            function sendMessage() {
                const question = ui.messageInput.value.trim();
                if (!question || !socket || socket.readyState !== WebSocket.OPEN) return;
                
                console.log("üì§ Sending PDF question:", question);
                addMessage(question, 'user', 'pdf_chat');
                
                const historyForAI = pdfChatHistory.slice(0, -1);
                socket.send(JSON.stringify({ 
                    type: 'ask', 
                    data: { question: question, history: historyForAI } 
                }));
                
                ui.messageInput.value = '';
                setUIState('ai_thinking', 'AI is thinking...');
            }
            
            function sendMessageAIChat() {
                const question = ui.messageInputAI.value.trim();
                if ((!question && !uploadedImageB64) || !socket || socket.readyState !== WebSocket.OPEN) return;
                
                console.log("üì§ Sending AI chat message:", question, "Has image:", !!uploadedImageB64);
                addMessage(question, 'user', 'ai_chat', uploadedImageB64);
                
                const historyForAI = aiChatHistory.slice(0, -1);
                const payload = { 
                    question: question, 
                    history: historyForAI, 
                    image_b64: uploadedImageB64 
                };
                const taskType = uploadedImageB64 ? 'general_chat_with_image' : 'general_chat';
                
                socket.send(JSON.stringify({ 
                    type: taskType, 
                    data: payload 
                }));
                
                ui.messageInputAI.value = '';
                ui.imagePreviewContainerAI.style.display = 'none';
                uploadedImageB64 = null;
                setUIState('ai_thinking', 'AI is thinking...');
            }

            function handleImageFile(file) {
                if (!file || !file.type.startsWith('image/')) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedImageB64 = event.target.result.split(',')[1];
                    ui.imagePreviewAI.src = event.target.result;
                    ui.imagePreviewContainerAI.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
            
            // Tab switching
            ui.tabChatPDF.addEventListener('click', () => { 
                activeTab = 'pdf_chat'; 
                ui.viewChatPDF.style.display = 'grid'; 
                ui.viewAIChat.style.display = 'none'; 
                ui.tabChatPDF.classList.add('active'); 
                ui.tabAIChat.classList.remove('active'); 
            });
            
            ui.tabAIChat.addEventListener('click', () => { 
                activeTab = 'ai_chat'; 
                ui.viewChatPDF.style.display = 'none'; 
                ui.viewAIChat.style.display = 'flex'; 
                ui.tabChatPDF.classList.remove('active'); 
                ui.tabAIChat.classList.add('active'); 
            });
            
            // Sidebar controls
            ui.openSidebarButton.addEventListener('click', () => { 
                loadSavedChats(); 
                ui.sidebar.classList.remove('-translate-x-full'); 
            });
            
            ui.closeSidebarButton.addEventListener('click', () => 
                ui.sidebar.classList.add('-translate-x-full')
            );
            
            ui.newChatButton.addEventListener('click', () => { 
                startNewChat(); 
                ui.sidebar.classList.add('-translate-x-full'); 
            });
            
            // PDF chat controls
            ui.pdfUploadInput.addEventListener('change', uploadPDF);
            ui.sendButton.addEventListener('click', sendMessage);
            ui.messageInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessage(); 
                } 
            });
            
            // AI chat controls
            ui.sendButtonAI.addEventListener('click', sendMessageAIChat);
            ui.messageInputAI.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    sendMessageAIChat(); 
                } 
            });
            
            ui.imageUploadAI.addEventListener('change', (e) => handleImageFile(e.target.files[0]));
            
            ui.removeImageButtonAI.addEventListener('click', () => {
                uploadedImageB64 = null;
                ui.imagePreviewContainerAI.style.display = 'none';
                ui.imageUploadAI.value = '';
            });
            
            ui.messageInputAI.addEventListener('paste', (e) => {
                const items = (e.clipboardData || window.clipboardData).items;
                for (const item of items) {
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        e.preventDefault();
                        const file = item.getAsFile();
                        handleImageFile(file);
                        return;
                    }
                }
            });

            // Initialize
            console.log("üöÄ Initializing AI Toolkit with user ID:", userId);
            statusInterval = setInterval(checkWorkerStatus, 3000);
            checkWorkerStatus();
            ui.tabChatPDF.click();
        });
    </script>
</body>
</html>
